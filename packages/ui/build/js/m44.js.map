{"version":3,"file":"m44.js","sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/fp-ts/lib/Array.js","webpack:///./node_modules/fp-ts/lib/ChainRec.js","webpack:///./node_modules/fp-ts/lib/Either.js","webpack:///./node_modules/fp-ts/lib/Monoid.js","webpack:///./node_modules/fp-ts/lib/Option.js","webpack:///./node_modules/fp-ts/lib/Ord.js","webpack:///./node_modules/fp-ts/lib/Ordering.js","webpack:///./node_modules/fp-ts/lib/Semigroup.js","webpack:///./node_modules/fp-ts/lib/Setoid.js","webpack:///./node_modules/fp-ts/lib/function.js","webpack:///./node_modules/io-ts-reporters/target/src/index.js","webpack:///./node_modules/io-ts/es6/index.js","webpack:///packages/browser/index.ts","webpack:///packages/browser/modules/browser-measure.ts","webpack:///packages/browser/modules/canvas-render.ts","webpack:///packages/browser/modules/image-localstorage.ts","webpack:///packages/core/app.ts","webpack:///packages/core/utils/icon-dict.ts","webpack:///packages/core/utils/icon-repo.ts","webpack:///packages/types/board.ts","webpack:///packages/types/m44.ts","webpack:///packages/types/sed_data.ts","webpack:///packages/types/shared.ts","webpack:///packages/ui/config.ts","webpack:///packages/ui/index.ts"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./packages/ui/index.ts\");\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar function_1 = require(\"./function\");\nvar Option_1 = require(\"./Option\");\nvar Ord_1 = require(\"./Ord\");\nvar Setoid_1 = require(\"./Setoid\");\nexports.URI = 'Array';\n/**\n * @since 1.17.0\n */\nexports.getShow = function (S) {\n    return {\n        show: function (arr) { return \"[\" + arr.map(S.show).join(', ') + \"]\"; }\n    };\n};\n/**\n *\n * @example\n * import { getMonoid } from 'fp-ts/lib/Array'\n *\n * const M = getMonoid<number>()\n * assert.deepStrictEqual(M.concat([1, 2], [3, 4]), [1, 2, 3, 4])\n *\n * @since 1.0.0\n */\nexports.getMonoid = function () {\n    return {\n        concat: function_1.concat,\n        empty: exports.empty\n    };\n};\n/**\n * Derives a Setoid over the Array of a given element type from the Setoid of that type. The derived setoid defines two\n * arrays as equal if all elements of both arrays are compared equal pairwise with the given setoid `S`. In case of\n * arrays of different lengths, the result is non equality.\n *\n *\n * @example\n * import { ordString } from 'fp-ts/lib/Ord'\n * import { getSetoid } from 'fp-ts/lib/Array'\n *\n * const O = getSetoid(ordString)\n * assert.strictEqual(O.equals(['a', 'b'], ['a', 'b']), true)\n * assert.strictEqual(O.equals(['a'], []), false)\n *\n * @since 1.0.0\n */\nexports.getSetoid = function (S) {\n    return Setoid_1.getArraySetoid(S);\n};\n/**\n * Derives an `Ord` over the Array of a given element type from the `Ord` of that type. The ordering between two such\n * arrays is equal to: the first non equal comparison of each arrays elements taken pairwise in increasing order, in\n * case of equality over all the pairwise elements; the longest array is considered the greatest, if both arrays have\n * the same length, the result is equality.\n *\n *\n * @example\n * import { getOrd } from 'fp-ts/lib/Array'\n * import { ordString } from 'fp-ts/lib/Ord'\n *\n * const O = getOrd(ordString)\n * assert.strictEqual(O.compare(['b'], ['a']), 1)\n * assert.strictEqual(O.compare(['a'], ['a']), 0)\n * assert.strictEqual(O.compare(['a'], ['b']), -1)\n *\n *\n * @since 1.2.0\n */\nexports.getOrd = function (O) {\n    return Ord_1.fromCompare(function (a, b) {\n        var aLen = a.length;\n        var bLen = b.length;\n        var len = Math.min(aLen, bLen);\n        for (var i = 0; i < len; i++) {\n            var order = O.compare(a[i], b[i]);\n            if (order !== 0) {\n                return order;\n            }\n        }\n        return Ord_1.ordNumber.compare(aLen, bLen);\n    });\n};\nvar map = function (fa, f) {\n    return fa.map(function (a) { return f(a); });\n};\nvar mapWithIndex = function (fa, f) {\n    return fa.map(function (a, i) { return f(i, a); });\n};\nvar of = function (a) {\n    return [a];\n};\nvar ap = function (fab, fa) {\n    return exports.flatten(map(fab, function (f) { return map(fa, f); }));\n};\nvar chain = function (fa, f) {\n    var resLen = 0;\n    var l = fa.length;\n    var temp = new Array(l);\n    for (var i = 0; i < l; i++) {\n        var e = fa[i];\n        var arr = f(e);\n        resLen += arr.length;\n        temp[i] = arr;\n    }\n    var r = Array(resLen);\n    var start = 0;\n    for (var i = 0; i < l; i++) {\n        var arr = temp[i];\n        var l_1 = arr.length;\n        for (var j = 0; j < l_1; j++) {\n            r[j + start] = arr[j];\n        }\n        start += l_1;\n    }\n    return r;\n};\nvar reduce = function (fa, b, f) {\n    return reduceWithIndex(fa, b, function (_, b, a) { return f(b, a); });\n};\nvar foldMap = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (fa, f) { return foldMapWithIndexM(fa, function (_, a) { return f(a); }); };\n};\nvar reduceRight = function (fa, b, f) {\n    return foldrWithIndex(fa, b, function (_, a, b) { return f(a, b); });\n};\nvar reduceWithIndex = function (fa, b, f) {\n    var l = fa.length;\n    var r = b;\n    for (var i = 0; i < l; i++) {\n        r = f(i, r, fa[i]);\n    }\n    return r;\n};\nvar foldMapWithIndex = function (M) { return function (fa, f) {\n    return fa.reduce(function (b, a, i) { return M.concat(b, f(i, a)); }, M.empty);\n}; };\nvar foldrWithIndex = function (fa, b, f) {\n    return fa.reduceRight(function (b, a, i) { return f(i, a, b); }, b);\n};\nfunction traverse(F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (ta, f) { return traverseWithIndexF(ta, function (_, a) { return f(a); }); };\n}\nexports.traverse = traverse;\nvar sequence = function (F) { return function (ta) {\n    return reduce(ta, F.of(zero()), function (fas, fa) { return F.ap(F.map(fas, function (as) { return function (a) { return exports.snoc(as, a); }; }), fa); });\n}; };\n/**\n * An empty array\n *\n *\n * @since 1.9.0\n */\nexports.empty = [];\nvar zero = function () { return exports.empty; };\nvar alt = function_1.concat;\nvar unfoldr = function (b, f) {\n    var ret = [];\n    var bb = b;\n    while (true) {\n        var mt = f(bb);\n        if (mt.isSome()) {\n            var _a = mt.value, a = _a[0], b_1 = _a[1];\n            ret.push(a);\n            bb = b_1;\n        }\n        else {\n            break;\n        }\n    }\n    return ret;\n};\n/**\n * Return a list of length `n` with element `i` initialized with `f(i)`\n *\n * @example\n * import { makeBy } from 'fp-ts/lib/Array'\n *\n * const double = (n: number): number => n * 2\n * assert.deepStrictEqual(makeBy(5, double), [0, 2, 4, 6, 8])\n *\n *\n * @since 1.10.0\n */\nexports.makeBy = function (n, f) {\n    var r = [];\n    for (var i = 0; i < n; i++) {\n        r.push(f(i));\n    }\n    return r;\n};\n/**\n * Create an array containing a range of integers, including both endpoints\n *\n * @example\n * import { range } from 'fp-ts/lib/Array'\n *\n * assert.deepStrictEqual(range(1, 5), [1, 2, 3, 4, 5])\n *\n *\n * @since 1.10.0\n */\nexports.range = function (start, end) {\n    return exports.makeBy(end - start + 1, function (i) { return start + i; });\n};\n/**\n * Create an array containing a value repeated the specified number of times\n *\n * @example\n * import { replicate } from 'fp-ts/lib/Array'\n *\n * assert.deepStrictEqual(replicate(3, 'a'), ['a', 'a', 'a'])\n *\n *\n * @since 1.10.0\n */\nexports.replicate = function (n, a) {\n    return exports.makeBy(n, function () { return a; });\n};\nvar extend = function (fa, f) {\n    return fa.map(function (_, i, as) { return f(as.slice(i)); });\n};\n/**\n * Removes one level of nesting\n *\n * @example\n * import { flatten } from 'fp-ts/lib/Array'\n *\n * assert.deepStrictEqual(flatten([[1], [2], [3]]), [1, 2, 3])\n *\n * @since 1.0.0\n */\nexports.flatten = function (ffa) {\n    var rLen = 0;\n    var len = ffa.length;\n    for (var i = 0; i < len; i++) {\n        rLen += ffa[i].length;\n    }\n    var r = Array(rLen);\n    var start = 0;\n    for (var i = 0; i < len; i++) {\n        var arr = ffa[i];\n        var l = arr.length;\n        for (var j = 0; j < l; j++) {\n            r[j + start] = arr[j];\n        }\n        start += l;\n    }\n    return r;\n};\n/**\n * Break an array into its first element and remaining elements\n *\n * @example\n * import { fold } from 'fp-ts/lib/Array'\n *\n * const len = <A>(as: Array<A>): number => fold(as, 0, (_, tail) => 1 + len(tail))\n * assert.strictEqual(len([1, 2, 3]), 3)\n *\n * @since 1.0.0\n */\nexports.fold = function (as, b, cons) {\n    return exports.isEmpty(as) ? b : cons(as[0], as.slice(1));\n};\n/**\n * Lazy version of `fold`\n *\n * @since 1.0.0\n */\nexports.foldL = function (as, nil, cons) {\n    return exports.isEmpty(as) ? nil() : cons(as[0], as.slice(1));\n};\n/**\n * Break an array into its initial elements and the last element\n *\n * @since 1.7.0\n * @param as\n * @param b\n * @param cons\n */\nexports.foldr = function (as, b, cons) {\n    return exports.isEmpty(as) ? b : cons(as.slice(0, as.length - 1), as[as.length - 1]);\n};\n/**\n * Lazy version of `foldr`\n *\n * @since 1.7.0\n * @param as\n * @param nil\n * @param cons\n */\nexports.foldrL = function (as, nil, cons) {\n    return exports.isEmpty(as) ? nil() : cons(as.slice(0, as.length - 1), as[as.length - 1]);\n};\n/**\n * Same as `reduce` but it carries over the intermediate steps\n *\n * ```ts\n * import { scanLeft } from 'fp-ts/lib/Array'\n *\n * assert.deepStrictEqual(scanLeft([1, 2, 3], 10, (b, a) => b - a), [ 10, 9, 7, 4 ])\n * ```\n *\n *\n * @since 1.1.0\n */\nexports.scanLeft = function (as, b, f) {\n    var l = as.length;\n    var r = new Array(l + 1);\n    r[0] = b;\n    for (var i = 0; i < l; i++) {\n        r[i + 1] = f(r[i], as[i]);\n    }\n    return r;\n};\n/**\n * Fold an array from the right, keeping all intermediate results instead of only the final result\n *\n * @example\n * import { scanRight } from 'fp-ts/lib/Array'\n *\n * assert.deepStrictEqual(scanRight([1, 2, 3], 10, (a, b) => b - a), [ 4, 5, 7, 10 ])\n *\n *\n * @since 1.1.0\n */\nexports.scanRight = function (as, b, f) {\n    var l = as.length;\n    var r = new Array(l + 1);\n    r[l] = b;\n    for (var i = l - 1; i >= 0; i--) {\n        r[i] = f(as[i], r[i + 1]);\n    }\n    return r;\n};\n/**\n * Test whether an array is empty\n *\n * @example\n * import { isEmpty } from 'fp-ts/lib/Array'\n *\n * assert.strictEqual(isEmpty([]), true)\n *\n * @since 1.0.0\n */\nexports.isEmpty = function (as) {\n    return as.length === 0;\n};\n/**\n * Test whether an array contains a particular index\n *\n * @since 1.0.0\n */\nexports.isOutOfBound = function (i, as) {\n    return i < 0 || i >= as.length;\n};\n/**\n * This function provides a safe way to read a value at a particular index from an array\n *\n * @example\n * import { lookup } from 'fp-ts/lib/Array'\n * import { some, none } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(lookup(1, [1, 2, 3]), some(2))\n * assert.deepStrictEqual(lookup(3, [1, 2, 3]), none)\n *\n * @since 1.14.0\n */\nexports.lookup = function (i, as) {\n    return exports.isOutOfBound(i, as) ? Option_1.none : Option_1.some(as[i]);\n};\n/**\n * Use `lookup` instead\n * @since 1.0.0\n * @deprecated\n */\nexports.index = function (i, as) {\n    return exports.lookup(i, as);\n};\n/**\n * Attaches an element to the front of an array, creating a new non empty array\n *\n * @example\n * import { cons } from 'fp-ts/lib/Array'\n *\n * assert.deepStrictEqual(cons(0, [1, 2, 3]), [0, 1, 2, 3])\n *\n * @since 1.0.0\n */\nexports.cons = function (a, as) {\n    var len = as.length;\n    var r = Array(len + 1);\n    for (var i = 0; i < len; i++) {\n        r[i + 1] = as[i];\n    }\n    r[0] = a;\n    return r;\n};\n/**\n * Append an element to the end of an array, creating a new non empty array\n *\n * @example\n * import { snoc } from 'fp-ts/lib/Array'\n *\n * assert.deepStrictEqual(snoc([1, 2, 3], 4), [1, 2, 3, 4])\n *\n * @since 1.0.0\n */\nexports.snoc = function (as, a) {\n    var len = as.length;\n    var r = Array(len + 1);\n    for (var i = 0; i < len; i++) {\n        r[i] = as[i];\n    }\n    r[len] = a;\n    return r;\n};\n/**\n * Get the first element in an array, or `None` if the array is empty\n *\n * @example\n * import { head } from 'fp-ts/lib/Array'\n * import { some, none } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(head([1, 2, 3]), some(1))\n * assert.deepStrictEqual(head([]), none)\n *\n * @since 1.0.0\n */\nexports.head = function (as) {\n    return exports.isEmpty(as) ? Option_1.none : Option_1.some(as[0]);\n};\n/**\n * Get the last element in an array, or `None` if the array is empty\n *\n * @example\n * import { last } from 'fp-ts/lib/Array'\n * import { some, none } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(last([1, 2, 3]), some(3))\n * assert.deepStrictEqual(last([]), none)\n *\n * @since 1.0.0\n */\nexports.last = function (as) {\n    return exports.lookup(as.length - 1, as);\n};\n/**\n * Get all but the first element of an array, creating a new array, or `None` if the array is empty\n *\n * @example\n * import { tail } from 'fp-ts/lib/Array'\n * import { some, none } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(tail([1, 2, 3]), some([2, 3]))\n * assert.deepStrictEqual(tail([]), none)\n *\n * @since 1.0.0\n */\nexports.tail = function (as) {\n    return exports.isEmpty(as) ? Option_1.none : Option_1.some(as.slice(1));\n};\n/**\n * Get all but the last element of an array, creating a new array, or `None` if the array is empty\n *\n * @example\n * import { init } from 'fp-ts/lib/Array'\n * import { some, none } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(init([1, 2, 3]), some([1, 2]))\n * assert.deepStrictEqual(init([]), none)\n *\n * @since 1.0.0\n */\nexports.init = function (as) {\n    var len = as.length;\n    return len === 0 ? Option_1.none : Option_1.some(as.slice(0, len - 1));\n};\n/**\n * Keep only a number of elements from the start of an array, creating a new array.\n * `n` must be a natural number\n *\n * @example\n * import { take } from 'fp-ts/lib/Array'\n *\n * assert.deepStrictEqual(take(2, [1, 2, 3]), [1, 2])\n *\n * @since 1.0.0\n */\nexports.take = function (n, as) {\n    return as.slice(0, n);\n};\n/**\n * Keep only a number of elements from the end of an array, creating a new array.\n * `n` must be a natural number\n *\n * @example\n * import { takeEnd } from 'fp-ts/lib/Array'\n *\n * assert.deepStrictEqual(takeEnd(2, [1, 2, 3, 4, 5]), [4, 5])\n *\n *\n * @since 1.10.0\n */\nexports.takeEnd = function (n, as) {\n    return n === 0 ? exports.empty : as.slice(-n);\n};\nfunction takeWhile(as, predicate) {\n    var i = spanIndexUncurry(as, predicate);\n    var init = Array(i);\n    for (var j = 0; j < i; j++) {\n        init[j] = as[j];\n    }\n    return init;\n}\nexports.takeWhile = takeWhile;\nvar spanIndexUncurry = function (as, predicate) {\n    var l = as.length;\n    var i = 0;\n    for (; i < l; i++) {\n        if (!predicate(as[i])) {\n            break;\n        }\n    }\n    return i;\n};\nfunction span(as, predicate) {\n    var i = spanIndexUncurry(as, predicate);\n    var init = Array(i);\n    for (var j = 0; j < i; j++) {\n        init[j] = as[j];\n    }\n    var l = as.length;\n    var rest = Array(l - i);\n    for (var j = i; j < l; j++) {\n        rest[j - i] = as[j];\n    }\n    return { init: init, rest: rest };\n}\nexports.span = span;\n/**\n * Drop a number of elements from the start of an array, creating a new array\n *\n * @example\n * import { drop } from 'fp-ts/lib/Array'\n *\n * assert.deepStrictEqual(drop(2, [1, 2, 3]), [3])\n *\n * @since 1.0.0\n */\nexports.drop = function (n, as) {\n    return as.slice(n, as.length);\n};\n/**\n * Drop a number of elements from the end of an array, creating a new array\n *\n * @example\n * import { dropEnd } from 'fp-ts/lib/Array'\n *\n * assert.deepStrictEqual(dropEnd(2, [1, 2, 3, 4, 5]), [1, 2, 3])\n *\n *\n * @since 1.10.0\n */\nexports.dropEnd = function (n, as) {\n    return as.slice(0, as.length - n);\n};\n/**\n * Remove the longest initial subarray for which all element satisfy the specified predicate, creating a new array\n *\n * @example\n * import { dropWhile } from 'fp-ts/lib/Array'\n *\n * assert.deepStrictEqual(dropWhile([1, 3, 2, 4, 5], n => n % 2 === 1), [2, 4, 5])\n *\n * @since 1.0.0\n */\nexports.dropWhile = function (as, predicate) {\n    var i = spanIndexUncurry(as, predicate);\n    var l = as.length;\n    var rest = Array(l - i);\n    for (var j = i; j < l; j++) {\n        rest[j - i] = as[j];\n    }\n    return rest;\n};\n/**\n * Find the first index for which a predicate holds\n *\n * @example\n * import { findIndex } from 'fp-ts/lib/Array'\n * import { some, none } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(findIndex([1, 2, 3], x => x === 2), some(1))\n * assert.deepStrictEqual(findIndex([], x => x === 2), none)\n *\n * @since 1.0.0\n */\nexports.findIndex = function (as, predicate) {\n    var len = as.length;\n    for (var i = 0; i < len; i++) {\n        if (predicate(as[i])) {\n            return Option_1.some(i);\n        }\n    }\n    return Option_1.none;\n};\nfunction findFirst(as, predicate) {\n    var len = as.length;\n    for (var i = 0; i < len; i++) {\n        if (predicate(as[i])) {\n            return Option_1.some(as[i]);\n        }\n    }\n    return Option_1.none;\n}\nexports.findFirst = findFirst;\n/**\n * Find the first element returned by an option based selector function\n *\n * @example\n * import { findFirstMap } from 'fp-ts/lib/Array'\n * import { some, none } from 'fp-ts/lib/Option'\n *\n * interface Person {\n *   name: string\n *   age?: number\n * }\n *\n * const persons: Array<Person> = [{ name: 'John' }, { name: 'Mary', age: 45 }, { name: 'Joey', age: 28 }]\n *\n * // returns the name of the first person that has an age\n * assert.deepStrictEqual(findFirstMap(persons, p => (p.age === undefined ? none : some(p.name))), some('Mary'))\n *\n * @since 1.16.0\n */\nexports.findFirstMap = function (arr, f) {\n    var len = arr.length;\n    for (var i = 0; i < len; i++) {\n        var v = f(arr[i]);\n        if (v.isSome()) {\n            return v;\n        }\n    }\n    return Option_1.none;\n};\nfunction findLast(as, predicate) {\n    var len = as.length;\n    for (var i = len - 1; i >= 0; i--) {\n        if (predicate(as[i])) {\n            return Option_1.some(as[i]);\n        }\n    }\n    return Option_1.none;\n}\nexports.findLast = findLast;\n/**\n * Find the last element returned by an option based selector function\n *\n * @example\n * import { findLastMap } from 'fp-ts/lib/Array'\n * import { some, none } from 'fp-ts/lib/Option'\n *\n * interface Person {\n *   name: string\n *   age?: number\n * }\n *\n * const persons: Array<Person> = [{ name: 'John' }, { name: 'Mary', age: 45 }, { name: 'Joey', age: 28 }]\n *\n * // returns the name of the last person that has an age\n * assert.deepStrictEqual(findLastMap(persons, p => (p.age === undefined ? none : some(p.name))), some('Joey'))\n *\n * @since 1.16.0\n */\nexports.findLastMap = function (arr, f) {\n    var len = arr.length;\n    for (var i = len - 1; i >= 0; i--) {\n        var v = f(arr[i]);\n        if (v.isSome()) {\n            return v;\n        }\n    }\n    return Option_1.none;\n};\n/**\n * Returns the index of the last element of the list which matches the predicate\n *\n * @example\n * import { findLastIndex } from 'fp-ts/lib/Array'\n * import { some, none } from 'fp-ts/lib/Option'\n *\n * interface X {\n *   a: number\n *   b: number\n * }\n * const xs: Array<X> = [{ a: 1, b: 0 }, { a: 1, b: 1 }]\n * assert.deepStrictEqual(findLastIndex(xs, x => x.a === 1), some(1))\n * assert.deepStrictEqual(findLastIndex(xs, x => x.a === 4), none)\n *\n *\n * @since 1.10.0\n */\nexports.findLastIndex = function (as, predicate) {\n    var len = as.length;\n    for (var i = len - 1; i >= 0; i--) {\n        if (predicate(as[i])) {\n            return Option_1.some(i);\n        }\n    }\n    return Option_1.none;\n};\n/**\n * Use `array.filter` instead\n *\n * @since 1.0.0\n * @deprecated\n */\nexports.refine = function (as, refinement) {\n    // tslint:disable-next-line: deprecation\n    return filter(as, refinement);\n};\n/**\n * @since 1.0.0\n */\nexports.copy = function (as) {\n    var l = as.length;\n    var r = Array(l);\n    for (var i = 0; i < l; i++) {\n        r[i] = as[i];\n    }\n    return r;\n};\n/**\n *\n * @since 1.0.0\n */\nexports.unsafeInsertAt = function (i, a, as) {\n    var xs = exports.copy(as);\n    xs.splice(i, 0, a);\n    return xs;\n};\n/**\n * Insert an element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { insertAt } from 'fp-ts/lib/Array'\n * import { some } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(insertAt(2, 5, [1, 2, 3, 4]), some([1, 2, 5, 3, 4]))\n *\n * @since 1.0.0\n */\nexports.insertAt = function (i, a, as) {\n    return i < 0 || i > as.length ? Option_1.none : Option_1.some(exports.unsafeInsertAt(i, a, as));\n};\n/**\n *\n * @since 1.0.0\n */\nexports.unsafeUpdateAt = function (i, a, as) {\n    if (as[i] === a) {\n        return as;\n    }\n    else {\n        var xs = exports.copy(as);\n        xs[i] = a;\n        return xs;\n    }\n};\n/**\n * Change the element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { updateAt } from 'fp-ts/lib/Array'\n * import { some, none } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(updateAt(1, 1, [1, 2, 3]), some([1, 1, 3]))\n * assert.deepStrictEqual(updateAt(1, 1, []), none)\n *\n * @since 1.0.0\n */\nexports.updateAt = function (i, a, as) {\n    return exports.isOutOfBound(i, as) ? Option_1.none : Option_1.some(exports.unsafeUpdateAt(i, a, as));\n};\n/**\n *\n * @since 1.0.0\n */\nexports.unsafeDeleteAt = function (i, as) {\n    var xs = exports.copy(as);\n    xs.splice(i, 1);\n    return xs;\n};\n/**\n * Delete the element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { deleteAt } from 'fp-ts/lib/Array'\n * import { some, none } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(deleteAt(0, [1, 2, 3]), some([2, 3]))\n * assert.deepStrictEqual(deleteAt(1, []), none)\n *\n * @since 1.0.0\n */\nexports.deleteAt = function (i, as) {\n    return exports.isOutOfBound(i, as) ? Option_1.none : Option_1.some(exports.unsafeDeleteAt(i, as));\n};\n/**\n * Apply a function to the element at the specified index, creating a new array, or returning `None` if the index is out\n * of bounds\n *\n * @example\n * import { modifyAt } from 'fp-ts/lib/Array'\n * import { some, none } from 'fp-ts/lib/Option'\n *\n * const double = (x: number): number => x * 2\n * assert.deepStrictEqual(modifyAt([1, 2, 3], 1, double), some([1, 4, 3]))\n * assert.deepStrictEqual(modifyAt([], 1, double), none)\n *\n * @since 1.0.0\n */\nexports.modifyAt = function (as, i, f) {\n    return exports.isOutOfBound(i, as) ? Option_1.none : Option_1.some(exports.unsafeUpdateAt(i, f(as[i]), as));\n};\n/**\n * Reverse an array, creating a new array\n *\n * @example\n * import { reverse } from 'fp-ts/lib/Array'\n *\n * assert.deepStrictEqual(reverse([1, 2, 3]), [3, 2, 1])\n *\n * @since 1.0.0\n */\nexports.reverse = function (as) {\n    return exports.copy(as).reverse();\n};\n/**\n * Extracts from an array of `Either` all the `Right` elements. All the `Right` elements are extracted in order\n *\n * @example\n * import { rights } from 'fp-ts/lib/Array'\n * import { right, left } from 'fp-ts/lib/Either'\n *\n * assert.deepStrictEqual(rights([right(1), left('foo'), right(2)]), [1, 2])\n *\n * @since 1.0.0\n */\nexports.rights = function (as) {\n    var r = [];\n    var len = as.length;\n    for (var i = 0; i < len; i++) {\n        var a = as[i];\n        if (a.isRight()) {\n            r.push(a.value);\n        }\n    }\n    return r;\n};\n/**\n * Extracts from an array of `Either` all the `Left` elements. All the `Left` elements are extracted in order\n *\n * @example\n * import { lefts } from 'fp-ts/lib/Array'\n * import { left, right } from 'fp-ts/lib/Either'\n *\n * assert.deepStrictEqual(lefts([right(1), left('foo'), right(2)]), ['foo'])\n *\n * @since 1.0.0\n */\nexports.lefts = function (as) {\n    var r = [];\n    var len = as.length;\n    for (var i = 0; i < len; i++) {\n        var a = as[i];\n        if (a.isLeft()) {\n            r.push(a.value);\n        }\n    }\n    return r;\n};\n/**\n * Sort the elements of an array in increasing order, creating a new array\n *\n * @example\n * import { sort } from 'fp-ts/lib/Array'\n * import { ordNumber } from 'fp-ts/lib/Ord'\n *\n * assert.deepStrictEqual(sort(ordNumber)([3, 2, 1]), [1, 2, 3])\n *\n * @since 1.0.0\n */\nexports.sort = function (O) { return function (as) {\n    return exports.copy(as).sort(O.compare);\n}; };\n/**\n * Apply a function to pairs of elements at the same index in two arrays, collecting the results in a new array. If one\n * input array is short, excess elements of the longer array are discarded.\n *\n * @example\n * import { zipWith } from 'fp-ts/lib/Array'\n *\n * assert.deepStrictEqual(zipWith([1, 2, 3], ['a', 'b', 'c', 'd'], (n, s) => s + n), ['a1', 'b2', 'c3'])\n *\n * @since 1.0.0\n */\nexports.zipWith = function (fa, fb, f) {\n    var fc = [];\n    var len = Math.min(fa.length, fb.length);\n    for (var i = 0; i < len; i++) {\n        fc[i] = f(fa[i], fb[i]);\n    }\n    return fc;\n};\n/**\n * Takes two arrays and returns an array of corresponding pairs. If one input array is short, excess elements of the\n * longer array are discarded\n *\n * @example\n * import { zip } from 'fp-ts/lib/Array'\n *\n * assert.deepStrictEqual(zip([1, 2, 3], ['a', 'b', 'c', 'd']), [[1, 'a'], [2, 'b'], [3, 'c']])\n *\n * @since 1.0.0\n */\nexports.zip = function (fa, fb) {\n    return exports.zipWith(fa, fb, function_1.tuple);\n};\n/**\n * The function is reverse of `zip`. Takes an array of pairs and return two corresponding arrays\n *\n * @example\n * import { unzip } from 'fp-ts/lib/Array'\n *\n * assert.deepStrictEqual(unzip([[1, 'a'], [2, 'b'], [3, 'c']]), [[1, 2, 3], ['a', 'b', 'c']])\n *\n *\n * @since 1.13.0\n */\nexports.unzip = function (as) {\n    var fa = [];\n    var fb = [];\n    for (var i = 0; i < as.length; i++) {\n        fa[i] = as[i][0];\n        fb[i] = as[i][1];\n    }\n    return [fa, fb];\n};\n/**\n * Rotate an array to the right by `n` steps\n *\n * @example\n * import { rotate } from 'fp-ts/lib/Array'\n *\n * assert.deepStrictEqual(rotate(2, [1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])\n *\n * @since 1.0.0\n */\nexports.rotate = function (n, xs) {\n    var len = xs.length;\n    if (n === 0 || len <= 1 || len === Math.abs(n)) {\n        return xs;\n    }\n    else if (n < 0) {\n        return exports.rotate(len + n, xs);\n    }\n    else {\n        return xs.slice(-n).concat(xs.slice(0, len - n));\n    }\n};\n/**\n * Test if a value is a member of an array. Takes a `Setoid<A>` as a single\n * argument which returns the function to use to search for a value of type `A` in\n * an array of type `Array<A>`.\n *\n * @example\n * import { elem } from 'fp-ts/lib/Array'\n * import { setoidNumber } from 'fp-ts/lib/Setoid'\n *\n * assert.strictEqual(elem(setoidNumber)(1, [1, 2, 3]), true)\n * assert.strictEqual(elem(setoidNumber)(4, [1, 2, 3]), false)\n *\n * @since 1.14.0\n */\nexports.elem = function (S) { return function (a, as) {\n    var predicate = function (e) { return S.equals(e, a); };\n    var i = 0;\n    var len = as.length;\n    for (; i < len; i++) {\n        if (predicate(as[i])) {\n            return true;\n        }\n    }\n    return false;\n}; };\n/**\n * Use `elem` instead\n * @since 1.3.0\n * @deprecated\n */\nexports.member = function (S) {\n    var has = exports.elem(S);\n    return function (as, a) { return has(a, as); };\n};\n/**\n * Remove duplicates from an array, keeping the first occurance of an element.\n *\n * @example\n * import { uniq } from 'fp-ts/lib/Array'\n * import { setoidNumber } from 'fp-ts/lib/Setoid'\n *\n * assert.deepStrictEqual(uniq(setoidNumber)([1, 2, 1]), [1, 2])\n *\n *\n * @since 1.3.0\n */\nexports.uniq = function (S) {\n    var elemS = exports.elem(S);\n    return function (as) {\n        var r = [];\n        var len = as.length;\n        var i = 0;\n        for (; i < len; i++) {\n            var a = as[i];\n            if (!elemS(a, r)) {\n                r.push(a);\n            }\n        }\n        return len === r.length ? as : r;\n    };\n};\n/**\n * Sort the elements of an array in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,\n * etc...\n *\n * @example\n * import { sortBy } from 'fp-ts/lib/Array'\n * import { contramap, ordString, ordNumber } from 'fp-ts/lib/Ord'\n *\n * interface Person {\n *   name: string\n *   age: number\n * }\n * const byName = contramap((p: Person) => p.name, ordString)\n * const byAge = contramap((p: Person) => p.age, ordNumber)\n *\n * const sortByNameByAge = sortBy([byName, byAge])\n *\n * if (sortByNameByAge.isSome()) {\n *   const persons = [{ name: 'a', age: 1 }, { name: 'b', age: 3 }, { name: 'c', age: 2 }, { name: 'b', age: 2 }]\n *   assert.deepStrictEqual(sortByNameByAge.value(persons), [\n *     { name: 'a', age: 1 },\n *     { name: 'b', age: 2 },\n *     { name: 'b', age: 3 },\n *     { name: 'c', age: 2 }\n *   ])\n * }\n *\n *\n * @since 1.3.0\n */\nexports.sortBy = function (ords) {\n    return exports.fold(ords, Option_1.none, function (head, tail) { return Option_1.some(exports.sortBy1(head, tail)); });\n};\n/**\n * Non failing version of `sortBy`\n * @example\n * import { sortBy1 } from 'fp-ts/lib/Array'\n * import { contramap, ordString, ordNumber } from 'fp-ts/lib/Ord'\n *\n * interface Person {\n *   name: string\n *   age: number\n * }\n * const byName = contramap((p: Person) => p.name, ordString)\n * const byAge = contramap((p: Person) => p.age, ordNumber)\n *\n * const sortByNameByAge = sortBy1(byName, [byAge])\n *\n * const persons = [{ name: 'a', age: 1 }, { name: 'b', age: 3 }, { name: 'c', age: 2 }, { name: 'b', age: 2 }]\n * assert.deepStrictEqual(sortByNameByAge(persons), [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 2 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 }\n * ])\n *\n *\n * @since 1.3.0\n */\nexports.sortBy1 = function (head, tail) {\n    return exports.sort(tail.reduce(Ord_1.getSemigroup().concat, head));\n};\n/**\n * Apply a function to each element in an array, keeping only the results which contain a value, creating a new array.\n *\n * Alias of `Filterable`'s `filterMap`\n *\n * @example\n * import { mapOption } from 'fp-ts/lib/Array'\n * import { Option, some, none } from 'fp-ts/lib/Option'\n *\n * const f = (n: number): Option<number> => (n % 2 === 0 ? none : some(n))\n * assert.deepStrictEqual(mapOption([1, 2, 3], f), [1, 3])\n *\n * @since 1.0.0\n */\nexports.mapOption = function (as, f) {\n    return filterMapWithIndex(as, function (_, a) { return f(a); });\n};\n/**\n * Filter an array of optional values, keeping only the elements which contain a value, creating a new array.\n *\n * Alias of `Compactable`'s `compact`\n *\n * @example\n * import { catOptions } from 'fp-ts/lib/Array'\n * import { some, none } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(catOptions([some(1), none, some(3)]), [1, 3])\n *\n * @since 1.0.0\n */\nexports.catOptions = function (as) { return exports.mapOption(as, function_1.identity); };\n/**\n * @example\n * import { array } from 'fp-ts/lib/Array'\n * import { left, right } from 'fp-ts/lib/Either'\n * import { identity } from 'fp-ts/lib/function'\n *\n * assert.deepStrictEqual(array.partitionMap([right(1), left('foo'), right(2)], identity), { left: ['foo'], right: [1, 2] })\n *\n * @since 1.0.0\n */\nexports.partitionMap = function (fa, f) {\n    return partitionMapWithIndex(fa, function (_, a) { return f(a); });\n};\nfunction filter(as, predicate) {\n    return as.filter(predicate);\n}\nexports.filter = filter;\nfunction partition(fa, p) {\n    return partitionWithIndex(fa, function (_, a) { return p(a); });\n}\nexports.partition = partition;\nvar compact = exports.catOptions;\nvar separate = function (fa) {\n    var left = [];\n    var right = [];\n    for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {\n        var e = fa_1[_i];\n        if (e.isLeft()) {\n            left.push(e.value);\n        }\n        else {\n            right.push(e.value);\n        }\n    }\n    return {\n        left: left,\n        right: right\n    };\n};\nvar filterMap = exports.mapOption;\nvar wither = function (F) {\n    var traverseF = traverse(F);\n    return function (wa, f) { return F.map(traverseF(wa, f), compact); };\n};\nvar wilt = function (F) {\n    var traverseF = traverse(F);\n    return function (wa, f) { return F.map(traverseF(wa, f), separate); };\n};\n/**\n * A useful recursion pattern for processing an array to produce a new array, often used for \"chopping\" up the input\n * array. Typically chop is called with some function that will consume an initial prefix of the array and produce a\n * value and the rest of the array.\n *\n * @example\n * import { Setoid, setoidNumber } from 'fp-ts/lib/Setoid'\n * import { chop, span } from 'fp-ts/lib/Array'\n *\n * const group = <A>(S: Setoid<A>) => (as: Array<A>): Array<Array<A>> => {\n *   return chop(as, as => {\n *     const { init, rest } = span(as, a => S.equals(a, as[0]))\n *     return [init, rest]\n *   })\n * }\n * assert.deepStrictEqual(group(setoidNumber)([1, 1, 2, 3, 3, 4]), [[1, 1], [2], [3, 3], [4]])\n *\n *\n * @since 1.10.0\n */\nexports.chop = function (as, f) {\n    var result = [];\n    var cs = as;\n    while (cs.length > 0) {\n        var _a = f(cs), b = _a[0], c = _a[1];\n        result.push(b);\n        cs = c;\n    }\n    return result;\n};\n/**\n * Splits an array into two pieces, the first piece has `n` elements.\n *\n * @example\n * import { split } from 'fp-ts/lib/Array'\n *\n * assert.deepStrictEqual(split(2, [1, 2, 3, 4, 5]), [[1, 2], [3, 4, 5]])\n *\n *\n * @since 1.10.0\n */\nexports.split = function (n, as) {\n    return [as.slice(0, n), as.slice(n)];\n};\n/**\n * Splits an array into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n * the array. Note that `chunksOf([], n)` is `[]`, not `[[]]`. This is intentional, and is consistent with a recursive\n * definition of `chunksOf`; it satisfies the property that\n *\n * ```ts\n * chunksOf(xs, n).concat(chunksOf(ys, n)) == chunksOf(xs.concat(ys)), n)\n * ```\n *\n * whenever `n` evenly divides the length of `xs`.\n *\n * @example\n * import { chunksOf } from 'fp-ts/lib/Array'\n *\n * assert.deepStrictEqual(chunksOf([1, 2, 3, 4, 5], 2), [[1, 2], [3, 4], [5]])\n *\n *\n * @since 1.10.0\n */\nexports.chunksOf = function (as, n) {\n    return exports.isOutOfBound(n - 1, as) ? [as] : exports.chop(as, function (as) { return exports.split(n, as); });\n};\nfunction comprehension(input, f, g) {\n    var go = function (scope, input) {\n        if (input.length === 0) {\n            return f.apply(void 0, scope) ? [g.apply(void 0, scope)] : exports.empty;\n        }\n        else {\n            return chain(input[0], function (x) { return go(exports.snoc(scope, x), input.slice(1)); });\n        }\n    };\n    return go(exports.empty, input);\n}\nexports.comprehension = comprehension;\n/**\n * Creates an array of unique values, in order, from all given arrays using a `Setoid` for equality comparisons\n *\n * @example\n * import { union } from 'fp-ts/lib/Array'\n * import { setoidNumber } from 'fp-ts/lib/Setoid'\n *\n * assert.deepStrictEqual(union(setoidNumber)([1, 2], [2, 3]), [1, 2, 3])\n *\n *\n * @since 1.12.0\n */\nexports.union = function (S) {\n    var elemS = exports.elem(S);\n    return function (xs, ys) { return function_1.concat(xs, ys.filter(function (a) { return !elemS(a, xs); })); };\n};\n/**\n * Creates an array of unique values that are included in all given arrays using a `Setoid` for equality\n * comparisons. The order and references of result values are determined by the first array.\n *\n * @example\n * import { intersection } from 'fp-ts/lib/Array'\n * import { setoidNumber } from 'fp-ts/lib/Setoid'\n *\n * assert.deepStrictEqual(intersection(setoidNumber)([1, 2], [2, 3]), [2])\n *\n *\n * @since 1.12.0\n */\nexports.intersection = function (S) {\n    var elemS = exports.elem(S);\n    return function (xs, ys) { return xs.filter(function (a) { return elemS(a, ys); }); };\n};\n/**\n * Creates an array of array values not included in the other given array using a `Setoid` for equality\n * comparisons. The order and references of result values are determined by the first array.\n *\n * @example\n * import { difference } from 'fp-ts/lib/Array'\n * import { setoidNumber } from 'fp-ts/lib/Setoid'\n *\n * assert.deepStrictEqual(difference(setoidNumber)([1, 2], [2, 3]), [1])\n *\n *\n * @since 1.12.0\n */\nexports.difference = function (S) {\n    var elemS = exports.elem(S);\n    return function (xs, ys) { return xs.filter(function (a) { return !elemS(a, ys); }); };\n};\nvar traverseWithIndex = function (F) { return function (ta, f) {\n    return reduceWithIndex(ta, F.of(zero()), function (i, fbs, a) {\n        return F.ap(F.map(fbs, function (bs) { return function (b) { return exports.snoc(bs, b); }; }), f(i, a));\n    });\n}; };\nvar partitionMapWithIndex = function (fa, f) {\n    var left = [];\n    var right = [];\n    for (var i = 0; i < fa.length; i++) {\n        var e = f(i, fa[i]);\n        if (e.isLeft()) {\n            left.push(e.value);\n        }\n        else {\n            right.push(e.value);\n        }\n    }\n    return {\n        left: left,\n        right: right\n    };\n};\nvar partitionWithIndex = function (fa, p) {\n    var left = [];\n    var right = [];\n    for (var i = 0; i < fa.length; i++) {\n        var a = fa[i];\n        if (p(i, a)) {\n            right.push(a);\n        }\n        else {\n            left.push(a);\n        }\n    }\n    return {\n        left: left,\n        right: right\n    };\n};\nvar filterMapWithIndex = function (fa, f) {\n    var result = [];\n    for (var i = 0; i < fa.length; i++) {\n        var optionB = f(i, fa[i]);\n        if (optionB.isSome()) {\n            result.push(optionB.value);\n        }\n    }\n    return result;\n};\nvar filterWithIndex = function (fa, p) {\n    return fa.filter(function (a, i) { return p(i, a); });\n};\n/**\n * @since 1.0.0\n */\nexports.array = {\n    URI: exports.URI,\n    map: map,\n    mapWithIndex: mapWithIndex,\n    compact: compact,\n    separate: separate,\n    filter: filter,\n    filterMap: filterMap,\n    partition: partition,\n    partitionMap: exports.partitionMap,\n    of: of,\n    ap: ap,\n    chain: chain,\n    reduce: reduce,\n    foldMap: foldMap,\n    foldr: reduceRight,\n    unfoldr: unfoldr,\n    traverse: traverse,\n    sequence: sequence,\n    zero: zero,\n    alt: alt,\n    extend: extend,\n    wither: wither,\n    wilt: wilt,\n    reduceWithIndex: reduceWithIndex,\n    foldMapWithIndex: foldMapWithIndex,\n    foldrWithIndex: foldrWithIndex,\n    traverseWithIndex: traverseWithIndex,\n    partitionMapWithIndex: partitionMapWithIndex,\n    partitionWithIndex: partitionWithIndex,\n    filterMapWithIndex: filterMapWithIndex,\n    filterWithIndex: filterWithIndex\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @since 1.0.0\n */\nexports.tailRec = function (f, a) {\n    var v = f(a);\n    while (v.isLeft()) {\n        v = f(v.value);\n    }\n    return v.value;\n};\n","\"use strict\";\n/**\n * @file Represents a value of one of two possible types (a disjoint union).\n *\n * An instance of `Either` is either an instance of `Left` or `Right`.\n *\n * A common use of `Either` is as an alternative to `Option` for dealing with possible missing values. In this usage,\n * `None` is replaced with a `Left` which can contain useful information. `Right` takes the place of `Some`. Convention\n * dictates that `Left` is used for failure and `Right` is used for success.\n *\n * For example, you could use `Either<string, number>` to detect whether a received input is a `string` or a `number`.\n *\n * ```ts\n * const parse = (errorMessage: string) => (input: string): Either<string, number> => {\n *   const n = parseInt(input, 10)\n *   return isNaN(n) ? left(errorMessage) : right(n)\n * }\n * ```\n *\n * `Either` is right-biased, which means that `Right` is assumed to be the default case to operate on. If it is `Left`,\n * operations like `map`, `chain`, ... return the `Left` value unchanged:\n *\n * ```ts\n * right(12).map(double) // right(24)\n * left(23).map(double)  // left(23)\n * ```\n */\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ChainRec_1 = require(\"./ChainRec\");\nvar function_1 = require(\"./function\");\nvar Setoid_1 = require(\"./Setoid\");\nexports.URI = 'Either';\n/**\n * Left side of `Either`\n */\nvar Left = /** @class */ (function () {\n    function Left(value) {\n        this.value = value;\n        this._tag = 'Left';\n    }\n    /** The given function is applied if this is a `Right` */\n    Left.prototype.map = function (f) {\n        return this;\n    };\n    Left.prototype.ap = function (fab) {\n        return (fab.isLeft() ? fab : this);\n    };\n    /**\n     * Flipped version of `ap`\n     */\n    Left.prototype.ap_ = function (fb) {\n        return fb.ap(this);\n    };\n    /** Binds the given function across `Right` */\n    Left.prototype.chain = function (f) {\n        return this;\n    };\n    Left.prototype.bimap = function (f, g) {\n        return new Left(f(this.value));\n    };\n    Left.prototype.alt = function (fy) {\n        return fy;\n    };\n    /**\n     * Lazy version of `alt`\n     *\n     * @example\n     * import { right } from 'fp-ts/lib/Either'\n     *\n     * assert.deepStrictEqual(right(1).orElse(() => right(2)), right(1))\n     *\n     * @since 1.6.0\n     */\n    Left.prototype.orElse = function (fy) {\n        return fy(this.value);\n    };\n    Left.prototype.extend = function (f) {\n        return this;\n    };\n    Left.prototype.reduce = function (b, f) {\n        return b;\n    };\n    /** Applies a function to each case in the data structure */\n    Left.prototype.fold = function (onLeft, onRight) {\n        return onLeft(this.value);\n    };\n    /** Returns the value from this `Right` or the given argument if this is a `Left` */\n    Left.prototype.getOrElse = function (a) {\n        return a;\n    };\n    /** Returns the value from this `Right` or the result of given argument if this is a `Left` */\n    Left.prototype.getOrElseL = function (f) {\n        return f(this.value);\n    };\n    /** Maps the left side of the disjunction */\n    Left.prototype.mapLeft = function (f) {\n        return new Left(f(this.value));\n    };\n    Left.prototype.inspect = function () {\n        return this.toString();\n    };\n    Left.prototype.toString = function () {\n        return \"left(\" + function_1.toString(this.value) + \")\";\n    };\n    /** Returns `true` if the either is an instance of `Left`, `false` otherwise */\n    Left.prototype.isLeft = function () {\n        return true;\n    };\n    /** Returns `true` if the either is an instance of `Right`, `false` otherwise */\n    Left.prototype.isRight = function () {\n        return false;\n    };\n    /** Swaps the disjunction values */\n    Left.prototype.swap = function () {\n        return new Right(this.value);\n    };\n    Left.prototype.filterOrElse = function (_, zero) {\n        return this;\n    };\n    Left.prototype.filterOrElseL = function (_, zero) {\n        return this;\n    };\n    /**\n     * Use `filterOrElse` instead\n     * @since 1.6.0\n     * @deprecated\n     */\n    Left.prototype.refineOrElse = function (p, zero) {\n        return this;\n    };\n    /**\n     * Lazy version of `refineOrElse`\n     * Use `filterOrElseL` instead\n     * @since 1.6.0\n     * @deprecated\n     */\n    Left.prototype.refineOrElseL = function (p, zero) {\n        return this;\n    };\n    return Left;\n}());\nexports.Left = Left;\n/**\n * Right side of `Either`\n */\nvar Right = /** @class */ (function () {\n    function Right(value) {\n        this.value = value;\n        this._tag = 'Right';\n    }\n    Right.prototype.map = function (f) {\n        return new Right(f(this.value));\n    };\n    Right.prototype.ap = function (fab) {\n        return fab.isRight() ? this.map(fab.value) : exports.left(fab.value);\n    };\n    Right.prototype.ap_ = function (fb) {\n        return fb.ap(this);\n    };\n    Right.prototype.chain = function (f) {\n        return f(this.value);\n    };\n    Right.prototype.bimap = function (f, g) {\n        return new Right(g(this.value));\n    };\n    Right.prototype.alt = function (fy) {\n        return this;\n    };\n    Right.prototype.orElse = function (fy) {\n        return this;\n    };\n    Right.prototype.extend = function (f) {\n        return new Right(f(this));\n    };\n    Right.prototype.reduce = function (b, f) {\n        return f(b, this.value);\n    };\n    Right.prototype.fold = function (onLeft, onRight) {\n        return onRight(this.value);\n    };\n    Right.prototype.getOrElse = function (a) {\n        return this.value;\n    };\n    Right.prototype.getOrElseL = function (f) {\n        return this.value;\n    };\n    Right.prototype.mapLeft = function (f) {\n        return new Right(this.value);\n    };\n    Right.prototype.inspect = function () {\n        return this.toString();\n    };\n    Right.prototype.toString = function () {\n        return \"right(\" + function_1.toString(this.value) + \")\";\n    };\n    Right.prototype.isLeft = function () {\n        return false;\n    };\n    Right.prototype.isRight = function () {\n        return true;\n    };\n    Right.prototype.swap = function () {\n        return new Left(this.value);\n    };\n    Right.prototype.filterOrElse = function (p, zero) {\n        return p(this.value) ? this : exports.left(zero);\n    };\n    Right.prototype.filterOrElseL = function (p, zero) {\n        return p(this.value) ? this : exports.left(zero(this.value));\n    };\n    Right.prototype.refineOrElse = function (p, zero) {\n        return p(this.value) ? this : exports.left(zero);\n    };\n    Right.prototype.refineOrElseL = function (p, zero) {\n        return p(this.value) ? this : exports.left(zero(this.value));\n    };\n    return Right;\n}());\nexports.Right = Right;\n/**\n * @since 1.17.0\n */\nexports.getShow = function (SL, SA) {\n    return {\n        show: function (e) { return e.fold(function (l) { return \"left(\" + SL.show(l) + \")\"; }, function (a) { return \"right(\" + SA.show(a) + \")\"; }); }\n    };\n};\n/**\n * @since 1.0.0\n */\nexports.getSetoid = function (SL, SA) {\n    return Setoid_1.fromEquals(function (x, y) {\n        return x.isLeft() ? y.isLeft() && SL.equals(x.value, y.value) : y.isRight() && SA.equals(x.value, y.value);\n    });\n};\n/**\n * Semigroup returning the left-most non-`Left` value. If both operands are `Right`s then the inner values are\n * appended using the provided `Semigroup`\n *\n * @example\n * import { getSemigroup, left, right } from 'fp-ts/lib/Either'\n * import { semigroupSum } from 'fp-ts/lib/Semigroup'\n *\n * const S = getSemigroup<string, number>(semigroupSum)\n * assert.deepStrictEqual(S.concat(left('a'), left('b')), left('a'))\n * assert.deepStrictEqual(S.concat(left('a'), right(2)), right(2))\n * assert.deepStrictEqual(S.concat(right(1), left('b')), right(1))\n * assert.deepStrictEqual(S.concat(right(1), right(2)), right(3))\n *\n *\n * @since 1.7.0\n */\nexports.getSemigroup = function (S) {\n    return {\n        concat: function (x, y) { return (y.isLeft() ? x : x.isLeft() ? y : exports.right(S.concat(x.value, y.value))); }\n    };\n};\n/**\n * `Apply` semigroup\n *\n * @example\n * import { getApplySemigroup, left, right } from 'fp-ts/lib/Either'\n * import { semigroupSum } from 'fp-ts/lib/Semigroup'\n *\n * const S = getApplySemigroup<string, number>(semigroupSum)\n * assert.deepStrictEqual(S.concat(left('a'), left('b')), left('a'))\n * assert.deepStrictEqual(S.concat(left('a'), right(2)), left('a'))\n * assert.deepStrictEqual(S.concat(right(1), left('b')), left('b'))\n * assert.deepStrictEqual(S.concat(right(1), right(2)), right(3))\n *\n *\n * @since 1.7.0\n */\nexports.getApplySemigroup = function (S) {\n    return {\n        concat: function (x, y) { return (x.isLeft() ? x : y.isLeft() ? y : exports.right(S.concat(x.value, y.value))); }\n    };\n};\n/**\n * @since 1.7.0\n */\nexports.getApplyMonoid = function (M) {\n    return __assign({}, exports.getApplySemigroup(M), { empty: exports.right(M.empty) });\n};\nvar map = function (fa, f) {\n    return fa.map(f);\n};\nvar ap = function (fab, fa) {\n    return fa.ap(fab);\n};\nvar chain = function (fa, f) {\n    return fa.chain(f);\n};\nvar bimap = function (fla, f, g) {\n    return fla.bimap(f, g);\n};\nvar alt = function (fx, fy) {\n    return fx.alt(fy);\n};\nvar extend = function (ea, f) {\n    return ea.extend(f);\n};\nvar reduce = function (fa, b, f) {\n    return fa.reduce(b, f);\n};\nvar foldMap = function (M) { return function (fa, f) {\n    return fa.isLeft() ? M.empty : f(fa.value);\n}; };\nvar foldr = function (fa, b, f) {\n    return fa.isLeft() ? b : f(fa.value, b);\n};\nvar traverse = function (F) { return function (ta, f) {\n    return ta.isLeft() ? F.of(exports.left(ta.value)) : F.map(f(ta.value), of);\n}; };\nvar sequence = function (F) { return function (ta) {\n    return ta.isLeft() ? F.of(exports.left(ta.value)) : F.map(ta.value, exports.right);\n}; };\nvar chainRec = function (a, f) {\n    return ChainRec_1.tailRec(function (e) {\n        if (e.isLeft()) {\n            return exports.right(exports.left(e.value));\n        }\n        else {\n            var r = e.value;\n            return r.isLeft() ? exports.left(f(r.value)) : exports.right(exports.right(r.value));\n        }\n    }, f(a));\n};\n/**\n * Constructs a new `Either` holding a `Left` value. This usually represents a failure, due to the right-bias of this\n * structure\n *\n * @since 1.0.0\n */\nexports.left = function (l) {\n    return new Left(l);\n};\n/**\n * Constructs a new `Either` holding a `Right` value. This usually represents a successful value due to the right bias\n * of this structure\n *\n * @since 1.0.0\n */\nexports.right = function (a) {\n    return new Right(a);\n};\nvar of = exports.right;\nfunction fromPredicate(predicate, onFalse) {\n    return function (a) { return (predicate(a) ? exports.right(a) : exports.left(onFalse(a))); };\n}\nexports.fromPredicate = fromPredicate;\n/**\n * Use `fromPredicate` instead\n *\n * @since 1.6.0\n * @deprecated\n */\nexports.fromRefinement = function (refinement, onFalse) { return function (a) {\n    return refinement(a) ? exports.right(a) : exports.left(onFalse(a));\n}; };\n/**\n * Takes a default and a `Option` value, if the value is a `Some`, turn it into a `Right`, if the value is a `None` use\n * the provided default as a `Left`\n *\n * @since 1.0.0\n */\nexports.fromOption = function (defaultValue) { return function (fa) {\n    return fa.isNone() ? exports.left(defaultValue) : exports.right(fa.value);\n}; };\n/**\n * Lazy version of `fromOption`\n *\n * @since 1.3.0\n */\nexports.fromOptionL = function (defaultValue) { return function (fa) {\n    return fa.isNone() ? exports.left(defaultValue()) : exports.right(fa.value);\n}; };\n/**\n * Takes a default and a nullable value, if the value is not nully, turn it into a `Right`, if the value is nully use\n * the provided default as a `Left`\n *\n * @since 1.0.0\n */\nexports.fromNullable = function (defaultValue) { return function (a) {\n    return a == null ? exports.left(defaultValue) : exports.right(a);\n}; };\n/**\n * Default value for the optional `onerror` argument of `tryCatch`\n *\n * @since 1.0.0\n */\nexports.toError = function (e) {\n    if (e instanceof Error) {\n        return e;\n    }\n    else {\n        return new Error(String(e));\n    }\n};\n/**\n * Use `tryCatch2v` instead\n *\n * @since 1.0.0\n * @deprecated\n */\nexports.tryCatch = function (f, onerror) {\n    if (onerror === void 0) { onerror = exports.toError; }\n    return exports.tryCatch2v(f, onerror);\n};\n/**\n * Constructs a new `Either` from a function that might throw\n *\n * @example\n * import { Either, left, right, tryCatch2v } from 'fp-ts/lib/Either'\n *\n * const unsafeHead = <A>(as: Array<A>): A => {\n *   if (as.length > 0) {\n *     return as[0]\n *   } else {\n *     throw new Error('empty array')\n *   }\n * }\n *\n * const head = <A>(as: Array<A>): Either<Error, A> => {\n *   return tryCatch2v(() => unsafeHead(as), e => (e instanceof Error ? e : new Error('unknown error')))\n * }\n *\n * assert.deepStrictEqual(head([]), left(new Error('empty array')))\n * assert.deepStrictEqual(head([1, 2, 3]), right(1))\n *\n * @since 1.11.0\n */\nexports.tryCatch2v = function (f, onerror) {\n    try {\n        return exports.right(f());\n    }\n    catch (e) {\n        return exports.left(onerror(e));\n    }\n};\n/**\n * @since 1.0.0\n */\nexports.fromValidation = function (fa) {\n    return fa.isFailure() ? exports.left(fa.value) : exports.right(fa.value);\n};\n/**\n * Returns `true` if the either is an instance of `Left`, `false` otherwise\n *\n * @since 1.0.0\n */\nexports.isLeft = function (fa) {\n    return fa.isLeft();\n};\n/**\n * Returns `true` if the either is an instance of `Right`, `false` otherwise\n *\n * @since 1.0.0\n */\nexports.isRight = function (fa) {\n    return fa.isRight();\n};\n/**\n * Builds `Compactable` instance for `Either` given `Monoid` for the left side\n *\n * @since 1.7.0\n */\nfunction getCompactable(ML) {\n    var compact = function (fa) {\n        if (fa.isLeft()) {\n            return fa;\n        }\n        if (fa.value.isNone()) {\n            return exports.left(ML.empty);\n        }\n        return exports.right(fa.value.value);\n    };\n    var separate = function (fa) {\n        if (fa.isLeft()) {\n            return {\n                left: fa,\n                right: fa\n            };\n        }\n        if (fa.value.isLeft()) {\n            return {\n                left: exports.right(fa.value.value),\n                right: exports.left(ML.empty)\n            };\n        }\n        return {\n            left: exports.left(ML.empty),\n            right: exports.right(fa.value.value)\n        };\n    };\n    return {\n        URI: exports.URI,\n        _L: function_1.phantom,\n        compact: compact,\n        separate: separate\n    };\n}\nexports.getCompactable = getCompactable;\n/**\n * Builds `Filterable` instance for `Either` given `Monoid` for the left side\n *\n * @since 1.7.0\n */\nfunction getFilterable(ML) {\n    var C = getCompactable(ML);\n    var partitionMap = function (fa, f) {\n        if (fa.isLeft()) {\n            return {\n                left: fa,\n                right: fa\n            };\n        }\n        var e = f(fa.value);\n        if (e.isLeft()) {\n            return {\n                left: exports.right(e.value),\n                right: exports.left(ML.empty)\n            };\n        }\n        return {\n            left: exports.left(ML.empty),\n            right: exports.right(e.value)\n        };\n    };\n    var partition = function (fa, p) {\n        if (fa.isLeft()) {\n            return {\n                left: fa,\n                right: fa\n            };\n        }\n        if (p(fa.value)) {\n            return {\n                left: exports.left(ML.empty),\n                right: exports.right(fa.value)\n            };\n        }\n        return {\n            left: exports.right(fa.value),\n            right: exports.left(ML.empty)\n        };\n    };\n    var filterMap = function (fa, f) {\n        if (fa.isLeft()) {\n            return fa;\n        }\n        var optionB = f(fa.value);\n        if (optionB.isSome()) {\n            return exports.right(optionB.value);\n        }\n        return exports.left(ML.empty);\n    };\n    var filter = function (fa, p) { return fa.filterOrElse(p, ML.empty); };\n    return __assign({}, C, { map: map,\n        partitionMap: partitionMap,\n        filterMap: filterMap,\n        partition: partition,\n        filter: filter });\n}\nexports.getFilterable = getFilterable;\n/**\n * Builds `Witherable` instance for `Either` given `Monoid` for the left side\n *\n * @since 1.7.0\n */\nfunction getWitherable(ML) {\n    var filterableEither = getFilterable(ML);\n    var wither = function (F) {\n        var traverseF = traverse(F);\n        return function (wa, f) { return F.map(traverseF(wa, f), filterableEither.compact); };\n    };\n    var wilt = function (F) {\n        var traverseF = traverse(F);\n        return function (wa, f) { return F.map(traverseF(wa, f), filterableEither.separate); };\n    };\n    return __assign({}, filterableEither, { traverse: traverse,\n        reduce: reduce,\n        wither: wither,\n        wilt: wilt });\n}\nexports.getWitherable = getWitherable;\n/**\n * Converts a JavaScript Object Notation (JSON) string into an object.\n *\n * @example\n * import { parseJSON, toError } from 'fp-ts/lib/Either'\n *\n * assert.deepStrictEqual(parseJSON('{\"a\":1}', toError).value, { a: 1 })\n * assert.deepStrictEqual(parseJSON('{\"a\":}', toError).value, new SyntaxError('Unexpected token } in JSON at position 5'))\n *\n * @since 1.16.0\n */\nexports.parseJSON = function (s, onError) {\n    return exports.tryCatch2v(function () { return JSON.parse(s); }, onError);\n};\n/**\n * Converts a JavaScript value to a JavaScript Object Notation (JSON) string.\n *\n * @example\n * import { stringifyJSON, toError } from 'fp-ts/lib/Either'\n *\n * assert.deepStrictEqual(stringifyJSON({ a: 1 }, toError).value, '{\"a\":1}')\n * const circular: any = { ref: null }\n * circular.ref = circular\n * assert.deepStrictEqual(stringifyJSON(circular, toError).value, new TypeError('Converting circular structure to JSON'))\n *\n * @since 1.16.0\n */\nexports.stringifyJSON = function (u, onError) {\n    return exports.tryCatch2v(function () { return JSON.stringify(u); }, onError);\n};\nvar throwError = exports.left;\nvar fromEither = function_1.identity;\n/**\n * @since 1.0.0\n */\nexports.either = {\n    URI: exports.URI,\n    map: map,\n    of: of,\n    ap: ap,\n    chain: chain,\n    reduce: reduce,\n    foldMap: foldMap,\n    foldr: foldr,\n    traverse: traverse,\n    sequence: sequence,\n    bimap: bimap,\n    alt: alt,\n    extend: extend,\n    chainRec: chainRec,\n    throwError: throwError,\n    fromEither: fromEither,\n    fromOption: function (o, e) { return (o.isNone() ? throwError(e) : of(o.value)); }\n};\n","\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar function_1 = require(\"./function\");\nvar Semigroup_1 = require(\"./Semigroup\");\n/**\n * @since 1.0.0\n */\nexports.fold = function (M) {\n    return Semigroup_1.fold(M)(M.empty);\n};\n/**\n * Given a tuple of monoids returns a monoid for the tuple\n *\n * @example\n * import { getTupleMonoid, monoidString, monoidSum, monoidAll } from 'fp-ts/lib/Monoid'\n *\n * const M1 = getTupleMonoid(monoidString, monoidSum)\n * assert.deepStrictEqual(M1.concat(['a', 1], ['b', 2]), ['ab', 3])\n *\n * const M2 = getTupleMonoid(monoidString, monoidSum, monoidAll)\n * assert.deepStrictEqual(M2.concat(['a', 1, true], ['b', 2, false]), ['ab', 3, false])\n *\n * @since 1.0.0\n */\nexports.getTupleMonoid = function () {\n    var monoids = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        monoids[_i] = arguments[_i];\n    }\n    return __assign({}, Semigroup_1.getTupleSemigroup.apply(void 0, monoids), { empty: monoids.map(function (m) { return m.empty; }) });\n};\n/**\n * Use `getTupleMonoid` instead\n * @since 1.0.0\n * @deprecated\n */\nexports.getProductMonoid = function (MA, MB) {\n    return exports.getTupleMonoid(MA, MB);\n};\n/**\n * @since 1.0.0\n */\nexports.getDualMonoid = function (M) {\n    return __assign({}, Semigroup_1.getDualSemigroup(M), { empty: M.empty });\n};\n/**\n * Boolean monoid under conjunction\n * @since 1.0.0\n */\nexports.monoidAll = __assign({}, Semigroup_1.semigroupAll, { empty: true });\n/**\n * Boolean monoid under disjunction\n * @since 1.0.0\n */\nexports.monoidAny = __assign({}, Semigroup_1.semigroupAny, { empty: false });\nvar emptyArray = [];\n/**\n * @since 1.0.0\n */\nexports.unsafeMonoidArray = {\n    concat: function_1.concat,\n    empty: emptyArray\n};\n/**\n * `Monoid` under array concatenation\n *\n * @since 1.0.0\n */\nexports.getArrayMonoid = function () {\n    return exports.unsafeMonoidArray;\n};\nvar emptyObject = {};\nfunction getDictionaryMonoid(S) {\n    return __assign({}, Semigroup_1.getDictionarySemigroup(S), { empty: emptyObject });\n}\nexports.getDictionaryMonoid = getDictionaryMonoid;\n/**\n * Number monoid under addition\n * @since 1.0.0\n */\nexports.monoidSum = __assign({}, Semigroup_1.semigroupSum, { empty: 0 });\n/**\n * Number monoid under multiplication\n * @since 1.0.0\n */\nexports.monoidProduct = __assign({}, Semigroup_1.semigroupProduct, { empty: 1 });\n/**\n * @since 1.0.0\n */\nexports.monoidString = __assign({}, Semigroup_1.semigroupString, { empty: '' });\n/**\n * @since 1.0.0\n */\nexports.monoidVoid = __assign({}, Semigroup_1.semigroupVoid, { empty: undefined });\n/**\n * @since 1.0.0\n */\nexports.getFunctionMonoid = function (M) { return function () {\n    return __assign({}, Semigroup_1.getFunctionSemigroup(M)(), { empty: function () { return M.empty; } });\n}; };\n/**\n * @since 1.0.0\n */\nexports.getEndomorphismMonoid = function () {\n    return {\n        concat: function (x, y) { return function (a) { return x(y(a)); }; },\n        empty: function_1.identity\n    };\n};\n/**\n * @since 1.14.0\n */\nexports.getStructMonoid = function (monoids) {\n    var empty = {};\n    for (var _i = 0, _a = Object.keys(monoids); _i < _a.length; _i++) {\n        var key = _a[_i];\n        empty[key] = monoids[key].empty;\n    }\n    return __assign({}, Semigroup_1.getStructSemigroup(monoids), { empty: empty });\n};\n/**\n * Use `getStructMonoid` instead\n * @since 1.0.0\n * @deprecated\n */\nexports.getRecordMonoid = function (monoids) {\n    return exports.getStructMonoid(monoids);\n};\n/**\n * @since 1.9.0\n */\nexports.getMeetMonoid = function (B) {\n    return __assign({}, Semigroup_1.getMeetSemigroup(B), { empty: B.top });\n};\n/**\n * @since 1.9.0\n */\nexports.getJoinMonoid = function (B) {\n    return __assign({}, Semigroup_1.getJoinSemigroup(B), { empty: B.bottom });\n};\n","\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar function_1 = require(\"./function\");\nvar Monoid_1 = require(\"./Monoid\");\nvar Ord_1 = require(\"./Ord\");\nvar Setoid_1 = require(\"./Setoid\");\nexports.URI = 'Option';\nvar None = /** @class */ (function () {\n    function None() {\n        this._tag = 'None';\n    }\n    /**\n     * Takes a function `f` and an `Option` of `A`. Maps `f` either on `None` or `Some`, Option's data constructors. If it\n     * maps on `Some` then it will apply the `f` on `Some`'s value, if it maps on `None` it will return `None`.\n     *\n     * @example\n     * import { some } from 'fp-ts/lib/Option'\n     *\n     * assert.deepStrictEqual(some(1).map(n => n * 2), some(2))\n     */\n    None.prototype.map = function (f) {\n        return exports.none;\n    };\n    /**\n     * Maps `f` over this `Option`'s value. If the value returned from `f` is null or undefined, returns `None`\n     *\n     * @example\n     * import { none, some } from 'fp-ts/lib/Option'\n     *\n     * interface Foo {\n     *   bar?: {\n     *     baz?: string\n     *   }\n     * }\n     *\n     * assert.deepStrictEqual(\n     *   some<Foo>({ bar: { baz: 'quux' } })\n     *     .mapNullable(foo => foo.bar)\n     *     .mapNullable(bar => bar.baz),\n     *   some('quux')\n     * )\n     * assert.deepStrictEqual(\n     *   some<Foo>({ bar: {} })\n     *     .mapNullable(foo => foo.bar)\n     *     .mapNullable(bar => bar.baz),\n     *   none\n     * )\n     * assert.deepStrictEqual(\n     *   some<Foo>({})\n     *     .mapNullable(foo => foo.bar)\n     *     .mapNullable(bar => bar.baz),\n     *   none\n     * )\n     */\n    None.prototype.mapNullable = function (f) {\n        return exports.none;\n    };\n    /**\n     * `ap`, some may also call it \"apply\". Takes a function `fab` that is in the context of `Option`, and applies that\n     * function to this `Option`'s value. If the `Option` calling `ap` is `none` it will return `none`.\n     *\n     * @example\n     * import { some, none } from 'fp-ts/lib/Option'\n     *\n     * assert.deepStrictEqual(some(2).ap(some((x: number) => x + 1)), some(3))\n     * assert.deepStrictEqual(none.ap(some((x: number) => x + 1)), none)\n     */\n    None.prototype.ap = function (fab) {\n        return exports.none;\n    };\n    /**\n     * Flipped version of `ap`\n     *\n     * @example\n     * import { some, none } from 'fp-ts/lib/Option'\n     *\n     * assert.deepStrictEqual(some((x: number) => x + 1).ap_(some(2)), some(3))\n     * assert.deepStrictEqual(none.ap_(some(2)), none)\n     */\n    None.prototype.ap_ = function (fb) {\n        return fb.ap(this);\n    };\n    /**\n     * Returns the result of applying f to this `Option`'s value if this `Option` is nonempty. Returns `None` if this\n     * `Option` is empty. Slightly different from `map` in that `f` is expected to return an `Option` (which could be\n     * `None`)\n     */\n    None.prototype.chain = function (f) {\n        return exports.none;\n    };\n    None.prototype.reduce = function (b, f) {\n        return b;\n    };\n    /**\n     * `alt` short for alternative, takes another `Option`. If this `Option` is a `Some` type then it will be returned, if\n     * it is a `None` then it will return the next `Some` if it exist. If both are `None` then it will return `none`.\n     *\n     * @example\n     * import { Option, some, none } from 'fp-ts/lib/Option'\n     *\n     * assert.deepStrictEqual(some(2).alt(some(4)), some(2))\n     * const fa: Option<number> = none\n     * assert.deepStrictEqual(fa.alt(some(4)), some(4))\n     */\n    None.prototype.alt = function (fa) {\n        return fa;\n    };\n    /**\n     * Lazy version of `alt`\n     *\n     * @example\n     * import { some } from 'fp-ts/lib/Option'\n     *\n     * assert.deepStrictEqual(some(1).orElse(() => some(2)), some(1))\n     *\n     * @since 1.6.0\n     */\n    None.prototype.orElse = function (fa) {\n        return fa();\n    };\n    None.prototype.extend = function (f) {\n        return exports.none;\n    };\n    /**\n     * Applies a function to each case in the data structure\n     *\n     * @example\n     * import { none, some } from 'fp-ts/lib/Option'\n     *\n     * assert.strictEqual(some(1).fold('none', a => `some: ${a}`), 'some: 1')\n     * assert.strictEqual(none.fold('none', a => `some: ${a}`), 'none')\n     */\n    None.prototype.fold = function (b, onSome) {\n        return b;\n    };\n    /** Lazy version of `fold` */\n    None.prototype.foldL = function (onNone, onSome) {\n        return onNone();\n    };\n    /**\n     * Returns the value from this `Some` or the given argument if this is a `None`\n     *\n     * @example\n     * import { Option, none, some } from 'fp-ts/lib/Option'\n     *\n     * assert.strictEqual(some(1).getOrElse(0), 1)\n     * const fa: Option<number> = none\n     * assert.strictEqual(fa.getOrElse(0), 0)\n     */\n    None.prototype.getOrElse = function (a) {\n        return a;\n    };\n    /** Lazy version of `getOrElse` */\n    None.prototype.getOrElseL = function (f) {\n        return f();\n    };\n    /** Returns the value from this `Some` or `null` if this is a `None` */\n    None.prototype.toNullable = function () {\n        return null;\n    };\n    /** Returns the value from this `Some` or `undefined` if this is a `None` */\n    None.prototype.toUndefined = function () {\n        return undefined;\n    };\n    None.prototype.inspect = function () {\n        return this.toString();\n    };\n    None.prototype.toString = function () {\n        return 'none';\n    };\n    /** Returns `true` if the option has an element that is equal (as determined by `S`) to `a`, `false` otherwise */\n    None.prototype.contains = function (S, a) {\n        return false;\n    };\n    /** Returns `true` if the option is `None`, `false` otherwise */\n    None.prototype.isNone = function () {\n        return true;\n    };\n    /** Returns `true` if the option is an instance of `Some`, `false` otherwise */\n    None.prototype.isSome = function () {\n        return false;\n    };\n    /**\n     * Returns `true` if this option is non empty and the predicate `p` returns `true` when applied to this Option's value\n     */\n    None.prototype.exists = function (p) {\n        return false;\n    };\n    None.prototype.filter = function (p) {\n        return exports.none;\n    };\n    /**\n     * Use `filter` instead.\n     * Returns this option refined as `Option<B>` if it is non empty and the `refinement` returns `true` when applied to\n     * this Option's value. Otherwise returns `None`\n     * @since 1.3.0\n     * @deprecated\n     */\n    None.prototype.refine = function (refinement) {\n        return exports.none;\n    };\n    None.value = new None();\n    return None;\n}());\nexports.None = None;\n/**\n * @since 1.0.0\n */\nexports.none = None.value;\nvar Some = /** @class */ (function () {\n    function Some(value) {\n        this.value = value;\n        this._tag = 'Some';\n    }\n    Some.prototype.map = function (f) {\n        return new Some(f(this.value));\n    };\n    Some.prototype.mapNullable = function (f) {\n        return exports.fromNullable(f(this.value));\n    };\n    Some.prototype.ap = function (fab) {\n        return fab.isNone() ? exports.none : new Some(fab.value(this.value));\n    };\n    Some.prototype.ap_ = function (fb) {\n        return fb.ap(this);\n    };\n    Some.prototype.chain = function (f) {\n        return f(this.value);\n    };\n    Some.prototype.reduce = function (b, f) {\n        return f(b, this.value);\n    };\n    Some.prototype.alt = function (fa) {\n        return this;\n    };\n    Some.prototype.orElse = function (fa) {\n        return this;\n    };\n    Some.prototype.extend = function (f) {\n        return new Some(f(this));\n    };\n    Some.prototype.fold = function (b, onSome) {\n        return onSome(this.value);\n    };\n    Some.prototype.foldL = function (onNone, onSome) {\n        return onSome(this.value);\n    };\n    Some.prototype.getOrElse = function (a) {\n        return this.value;\n    };\n    Some.prototype.getOrElseL = function (f) {\n        return this.value;\n    };\n    Some.prototype.toNullable = function () {\n        return this.value;\n    };\n    Some.prototype.toUndefined = function () {\n        return this.value;\n    };\n    Some.prototype.inspect = function () {\n        return this.toString();\n    };\n    Some.prototype.toString = function () {\n        return \"some(\" + function_1.toString(this.value) + \")\";\n    };\n    Some.prototype.contains = function (S, a) {\n        return S.equals(this.value, a);\n    };\n    Some.prototype.isNone = function () {\n        return false;\n    };\n    Some.prototype.isSome = function () {\n        return true;\n    };\n    Some.prototype.exists = function (p) {\n        return p(this.value);\n    };\n    Some.prototype.filter = function (p) {\n        return this.exists(p) ? this : exports.none;\n    };\n    Some.prototype.refine = function (refinement) {\n        return this.filter(refinement);\n    };\n    return Some;\n}());\nexports.Some = Some;\n/**\n * @since 1.17.0\n */\nexports.getShow = function (S) {\n    return {\n        show: function (oa) { return oa.fold('none', function (a) { return \"some(\" + S.show(a) + \")\"; }); }\n    };\n};\n/**\n * @example\n * import { none, some, getSetoid } from 'fp-ts/lib/Option'\n * import { setoidNumber } from 'fp-ts/lib/Setoid'\n *\n * const S = getSetoid(setoidNumber)\n * assert.strictEqual(S.equals(none, none), true)\n * assert.strictEqual(S.equals(none, some(1)), false)\n * assert.strictEqual(S.equals(some(1), none), false)\n * assert.strictEqual(S.equals(some(1), some(2)), false)\n * assert.strictEqual(S.equals(some(1), some(1)), true)\n *\n * @since 1.0.0\n */\nexports.getSetoid = function (S) {\n    return Setoid_1.fromEquals(function (x, y) { return (x.isNone() ? y.isNone() : y.isNone() ? false : S.equals(x.value, y.value)); });\n};\n/**\n * The `Ord` instance allows `Option` values to be compared with\n * `compare`, whenever there is an `Ord` instance for\n * the type the `Option` contains.\n *\n * `None` is considered to be less than any `Some` value.\n *\n *\n * @example\n * import { none, some, getOrd } from 'fp-ts/lib/Option'\n * import { ordNumber } from 'fp-ts/lib/Ord'\n *\n * const O = getOrd(ordNumber)\n * assert.strictEqual(O.compare(none, none), 0)\n * assert.strictEqual(O.compare(none, some(1)), -1)\n * assert.strictEqual(O.compare(some(1), none), 1)\n * assert.strictEqual(O.compare(some(1), some(2)), -1)\n * assert.strictEqual(O.compare(some(1), some(1)), 0)\n *\n * @since 1.2.0\n */\nexports.getOrd = function (O) {\n    return Ord_1.fromCompare(function (x, y) { return (x.isSome() ? (y.isSome() ? O.compare(x.value, y.value) : 1) : -1); });\n};\nvar map = function (fa, f) {\n    return fa.map(f);\n};\n/**\n * @since 1.0.0\n */\nexports.some = function (a) {\n    return new Some(a);\n};\nvar of = exports.some;\nvar ap = function (fab, fa) {\n    return fa.ap(fab);\n};\nvar chain = function (fa, f) {\n    return fa.chain(f);\n};\nvar reduce = function (fa, b, f) {\n    return fa.reduce(b, f);\n};\nvar foldMap = function (M) { return function (fa, f) {\n    return fa.isNone() ? M.empty : f(fa.value);\n}; };\nvar foldr = function (fa, b, f) {\n    return fa.isNone() ? b : f(fa.value, b);\n};\nvar traverse = function (F) { return function (ta, f) {\n    return ta.isNone() ? F.of(exports.none) : F.map(f(ta.value), exports.some);\n}; };\nvar sequence = function (F) { return function (ta) {\n    return ta.isNone() ? F.of(exports.none) : F.map(ta.value, exports.some);\n}; };\nvar alt = function (fx, fy) {\n    return fx.alt(fy);\n};\nvar extend = function (ea, f) {\n    return ea.extend(f);\n};\nvar zero = function () {\n    return exports.none;\n};\n/**\n * `Apply` semigroup\n *\n * | x       | y       | concat(x, y)       |\n * | ------- | ------- | ------------------ |\n * | none    | none    | none               |\n * | some(a) | none    | none               |\n * | none    | some(a) | none               |\n * | some(a) | some(b) | some(concat(a, b)) |\n *\n * @example\n * import { getApplySemigroup, some, none } from 'fp-ts/lib/Option'\n * import { semigroupSum } from 'fp-ts/lib/Semigroup'\n *\n * const S = getApplySemigroup(semigroupSum)\n * assert.deepStrictEqual(S.concat(none, none), none)\n * assert.deepStrictEqual(S.concat(some(1), none), none)\n * assert.deepStrictEqual(S.concat(none, some(1)), none)\n * assert.deepStrictEqual(S.concat(some(1), some(2)), some(3))\n *\n * @since 1.7.0\n */\nexports.getApplySemigroup = function (S) {\n    return {\n        concat: function (x, y) { return (x.isSome() && y.isSome() ? exports.some(S.concat(x.value, y.value)) : exports.none); }\n    };\n};\n/**\n * @since 1.7.0\n */\nexports.getApplyMonoid = function (M) {\n    return __assign({}, exports.getApplySemigroup(M), { empty: exports.some(M.empty) });\n};\n/**\n * Monoid returning the left-most non-`None` value\n *\n * | x       | y       | concat(x, y) |\n * | ------- | ------- | ------------ |\n * | none    | none    | none         |\n * | some(a) | none    | some(a)      |\n * | none    | some(a) | some(a)      |\n * | some(a) | some(b) | some(a)      |\n *\n * @example\n * import { getFirstMonoid, some, none } from 'fp-ts/lib/Option'\n *\n * const M = getFirstMonoid<number>()\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(1)), some(1))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(1))\n *\n * @since 1.0.0\n */\nexports.getFirstMonoid = function () {\n    return {\n        concat: alt,\n        empty: exports.none\n    };\n};\n/**\n * Monoid returning the right-most non-`None` value\n *\n * | x       | y       | concat(x, y) |\n * | ------- | ------- | ------------ |\n * | none    | none    | none         |\n * | some(a) | none    | some(a)      |\n * | none    | some(a) | some(a)      |\n * | some(a) | some(b) | some(b)      |\n *\n * @example\n * import { getLastMonoid, some, none } from 'fp-ts/lib/Option'\n *\n * const M = getLastMonoid<number>()\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(1)), some(1))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(2))\n *\n * @since 1.0.0\n */\nexports.getLastMonoid = function () {\n    return Monoid_1.getDualMonoid(exports.getFirstMonoid());\n};\n/**\n * Monoid returning the left-most non-`None` value. If both operands are `Some`s then the inner values are\n * appended using the provided `Semigroup`\n *\n * | x       | y       | concat(x, y)       |\n * | ------- | ------- | ------------------ |\n * | none    | none    | none               |\n * | some(a) | none    | some(a)            |\n * | none    | some(a) | some(a)            |\n * | some(a) | some(b) | some(concat(a, b)) |\n *\n * @example\n * import { getMonoid, some, none } from 'fp-ts/lib/Option'\n * import { semigroupSum } from 'fp-ts/lib/Semigroup'\n *\n * const M = getMonoid(semigroupSum)\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(1)), some(1))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(3))\n *\n * @since 1.0.0\n */\nexports.getMonoid = function (S) {\n    return {\n        concat: function (x, y) { return (x.isNone() ? y : y.isNone() ? x : exports.some(S.concat(x.value, y.value))); },\n        empty: exports.none\n    };\n};\n/**\n * Constructs a new `Option` from a nullable type. If the value is `null` or `undefined`, returns `None`, otherwise\n * returns the value wrapped in a `Some`\n *\n * @example\n * import { none, some, fromNullable } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(fromNullable(undefined), none)\n * assert.deepStrictEqual(fromNullable(null), none)\n * assert.deepStrictEqual(fromNullable(1), some(1))\n *\n * @since 1.0.0\n */\nexports.fromNullable = function (a) {\n    return a == null ? exports.none : new Some(a);\n};\nfunction fromPredicate(predicate) {\n    return function (a) { return (predicate(a) ? exports.some(a) : exports.none); };\n}\nexports.fromPredicate = fromPredicate;\n/**\n * Transforms an exception into an `Option`. If `f` throws, returns `None`, otherwise returns the output wrapped in\n * `Some`\n *\n * @example\n * import { none, some, tryCatch } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(\n *   tryCatch(() => {\n *     throw new Error()\n *   }),\n *   none\n * )\n * assert.deepStrictEqual(tryCatch(() => 1), some(1))\n *\n * @since 1.0.0\n */\nexports.tryCatch = function (f) {\n    try {\n        return exports.some(f());\n    }\n    catch (e) {\n        return exports.none;\n    }\n};\n/**\n * Constructs a new `Option` from a `Either`. If the value is a `Left`, returns `None`, otherwise returns the inner\n * value wrapped in a `Some`\n *\n * @example\n * import { none, some, fromEither } from 'fp-ts/lib/Option'\n * import { left, right } from 'fp-ts/lib/Either'\n *\n * assert.deepStrictEqual(fromEither(left(1)), none)\n * assert.deepStrictEqual(fromEither(right(1)), some(1))\n *\n * @since 1.0.0\n */\nexports.fromEither = function (fa) {\n    return fa.isLeft() ? exports.none : exports.some(fa.value);\n};\n/**\n * Returns `true` if the option is an instance of `Some`, `false` otherwise\n *\n * @since 1.0.0\n */\nexports.isSome = function (fa) {\n    return fa.isSome();\n};\n/**\n * Returns `true` if the option is `None`, `false` otherwise\n *\n * @since 1.0.0\n */\nexports.isNone = function (fa) {\n    return fa.isNone();\n};\n/**\n * Use `fromPredicate` instead.\n * Refinement version of `fromPredicate`\n *\n * @since 1.3.0\n * @deprecated\n */\nexports.fromRefinement = function (refinement) { return function (a) {\n    return refinement(a) ? exports.some(a) : exports.none;\n}; };\n/**\n * Returns a refinement from a prism.\n * This function ensures that a custom type guard definition is type-safe.\n *\n * ```ts\n * import { some, none, getRefinement } from 'fp-ts/lib/Option'\n *\n * type A = { type: 'A' }\n * type B = { type: 'B' }\n * type C = A | B\n *\n * const isA = (c: C): c is A => c.type === 'B' // <= typo but typescript doesn't complain\n * const isA = getRefinement<C, A>(c => (c.type === 'B' ? some(c) : none)) // static error: Type '\"B\"' is not assignable to type '\"A\"'\n * ```\n *\n * @since 1.7.0\n */\nexports.getRefinement = function (getOption) {\n    return function (a) { return getOption(a).isSome(); };\n};\nvar compact = function (fa) { return fa.chain(function_1.identity); };\nvar separate = function (fa) {\n    if (fa.isNone()) {\n        return {\n            left: exports.none,\n            right: exports.none\n        };\n    }\n    var e = fa.value;\n    if (e.isLeft()) {\n        return {\n            left: exports.some(e.value),\n            right: exports.none\n        };\n    }\n    return {\n        left: exports.none,\n        right: exports.some(e.value)\n    };\n};\nvar filter = function (fa, p) { return fa.filter(p); };\nvar filterMap = chain;\nvar partitionMap = function (fa, f) {\n    return separate(fa.map(f));\n};\nvar partition = function (fa, p) { return ({\n    left: fa.filter(function_1.not(p)),\n    right: fa.filter(p)\n}); };\nvar wither = function (F) { return function (fa, f) {\n    return fa.isNone() ? F.of(fa) : f(fa.value);\n}; };\nvar wilt = function (F) { return function (fa, f) {\n    if (fa.isNone()) {\n        return F.of({\n            left: exports.none,\n            right: exports.none\n        });\n    }\n    return F.map(f(fa.value), function (e) {\n        if (e.isLeft()) {\n            return {\n                left: exports.some(e.value),\n                right: exports.none\n            };\n        }\n        return {\n            left: exports.none,\n            right: exports.some(e.value)\n        };\n    });\n}; };\n/**\n * @since 1.0.0\n */\nexports.option = {\n    URI: exports.URI,\n    map: map,\n    of: of,\n    ap: ap,\n    chain: chain,\n    reduce: reduce,\n    foldMap: foldMap,\n    foldr: foldr,\n    traverse: traverse,\n    sequence: sequence,\n    zero: zero,\n    alt: alt,\n    extend: extend,\n    compact: compact,\n    separate: separate,\n    filter: filter,\n    filterMap: filterMap,\n    partition: partition,\n    partitionMap: partitionMap,\n    wither: wither,\n    wilt: wilt\n};\n","\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @file The `Ord` type class represents types which support comparisons with a _total order_.\n *\n * Instances should satisfy the laws of total orderings:\n *\n * 1. Reflexivity: `S.compare(a, a) <= 0`\n * 2. Antisymmetry: if `S.compare(a, b) <= 0` and `S.compare(b, a) <= 0` then `a <-> b`\n * 3. Transitivity: if `S.compare(a, b) <= 0` and `S.compare(b, c) <= 0` then `S.compare(a, c) <= 0`\n *\n * See [Getting started with fp-ts: Ord](https://dev.to/gcanti/getting-started-with-fp-ts-ord-5f1e)\n */\nvar Ordering_1 = require(\"./Ordering\");\nvar Setoid_1 = require(\"./Setoid\");\nvar function_1 = require(\"./function\");\n/**\n * @since 1.0.0\n */\nexports.unsafeCompare = function (x, y) {\n    return x < y ? -1 : x > y ? 1 : 0;\n};\n/**\n * @since 1.0.0\n */\nexports.ordString = __assign({}, Setoid_1.setoidString, { compare: exports.unsafeCompare });\n/**\n * @since 1.0.0\n */\nexports.ordNumber = __assign({}, Setoid_1.setoidNumber, { compare: exports.unsafeCompare });\n/**\n * @since 1.0.0\n */\nexports.ordBoolean = __assign({}, Setoid_1.setoidBoolean, { compare: exports.unsafeCompare });\n/**\n * Test whether one value is _strictly less than_ another\n *\n * @since 1.0.0\n */\nexports.lessThan = function (O) { return function (x, y) {\n    return O.compare(x, y) === -1;\n}; };\n/**\n * Test whether one value is _strictly greater than_ another\n *\n * @since 1.0.0\n */\nexports.greaterThan = function (O) { return function (x, y) {\n    return O.compare(x, y) === 1;\n}; };\n/**\n * Test whether one value is _non-strictly less than_ another\n *\n * @since 1.0.0\n */\nexports.lessThanOrEq = function (O) { return function (x, y) {\n    return O.compare(x, y) !== 1;\n}; };\n/**\n * Test whether one value is _non-strictly greater than_ another\n *\n * @since 1.0.0\n */\nexports.greaterThanOrEq = function (O) { return function (x, y) {\n    return O.compare(x, y) !== -1;\n}; };\n/**\n * Take the minimum of two values. If they are considered equal, the first argument is chosen\n *\n * @since 1.0.0\n */\nexports.min = function (O) { return function (x, y) {\n    return O.compare(x, y) === 1 ? y : x;\n}; };\n/**\n * Take the maximum of two values. If they are considered equal, the first argument is chosen\n *\n * @since 1.0.0\n */\nexports.max = function (O) { return function (x, y) {\n    return O.compare(x, y) === -1 ? y : x;\n}; };\n/**\n * Clamp a value between a minimum and a maximum\n *\n * @since 1.0.0\n */\nexports.clamp = function (O) {\n    var minO = exports.min(O);\n    var maxO = exports.max(O);\n    return function (low, hi) { return function (x) { return maxO(minO(x, hi), low); }; };\n};\n/**\n * Test whether a value is between a minimum and a maximum (inclusive)\n *\n * @since 1.0.0\n */\nexports.between = function (O) {\n    var lessThanO = exports.lessThan(O);\n    var greaterThanO = exports.greaterThan(O);\n    return function (low, hi) { return function (x) { return (lessThanO(x, low) || greaterThanO(x, hi) ? false : true); }; };\n};\n/**\n * @since 1.0.0\n */\nexports.fromCompare = function (compare) {\n    var optimizedCompare = function (x, y) { return (x === y ? 0 : compare(x, y)); };\n    return {\n        equals: function (x, y) { return optimizedCompare(x, y) === 0; },\n        compare: optimizedCompare\n    };\n};\n/**\n * @since 1.0.0\n */\nexports.contramap = function (f, fa) {\n    return exports.fromCompare(function_1.on(fa.compare)(f));\n};\n/**\n * @since 1.0.0\n */\nexports.getSemigroup = function () {\n    return {\n        concat: function (x, y) { return exports.fromCompare(function (a, b) { return Ordering_1.semigroupOrdering.concat(x.compare(a, b), y.compare(a, b)); }); }\n    };\n};\n/**\n * Given a tuple of `Ord`s returns an `Ord` for the tuple\n *\n * @example\n * import { getTupleOrd, ordString, ordNumber, ordBoolean } from 'fp-ts/lib/Ord'\n *\n * const O = getTupleOrd(ordString, ordNumber, ordBoolean)\n * assert.strictEqual(O.compare(['a', 1, true], ['b', 2, true]), -1)\n * assert.strictEqual(O.compare(['a', 1, true], ['a', 2, true]), -1)\n * assert.strictEqual(O.compare(['a', 1, true], ['a', 1, false]), 1)\n *\n * @since 1.14.3\n */\nexports.getTupleOrd = function () {\n    var ords = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        ords[_i] = arguments[_i];\n    }\n    var len = ords.length;\n    return exports.fromCompare(function (x, y) {\n        var i = 0;\n        for (; i < len - 1; i++) {\n            var r = ords[i].compare(x[i], y[i]);\n            if (r !== 0) {\n                return r;\n            }\n        }\n        return ords[i].compare(x[i], y[i]);\n    });\n};\n/**\n * Use `getTupleOrd` instead\n * @since 1.0.0\n * @deprecated\n */\nexports.getProductOrd = function (OA, OB) {\n    return exports.getTupleOrd(OA, OB);\n};\n/**\n * @since 1.3.0\n */\nexports.getDualOrd = function (O) {\n    return exports.fromCompare(function (x, y) { return O.compare(y, x); });\n};\n/**\n * @since 1.4.0\n */\nexports.ordDate = exports.contramap(function (date) { return date.valueOf(); }, exports.ordNumber);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @since 1.0.0\n */\nexports.sign = function (n) {\n    return n <= -1 ? -1 : n >= 1 ? 1 : 0;\n};\n/**\n * @since 1.0.0\n */\nexports.setoidOrdering = {\n    equals: function (x, y) { return x === y; }\n};\n/**\n * @since 1.0.0\n */\nexports.semigroupOrdering = {\n    concat: function (x, y) { return (x !== 0 ? x : y); }\n};\n/**\n * @since 1.0.0\n */\nexports.invert = function (O) {\n    switch (O) {\n        case -1:\n            return 1;\n        case 1:\n            return -1;\n        default:\n            return 0;\n    }\n};\n","\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @file See [Getting started with fp-ts: Semigroup](https://dev.to/gcanti/getting-started-with-fp-ts-semigroup-2mf7)\n */\nvar Ord_1 = require(\"./Ord\");\nvar function_1 = require(\"./function\");\n/**\n * @since 1.0.0\n */\nexports.fold = function (S) { return function (a) { return function (as) {\n    return as.reduce(S.concat, a);\n}; }; };\n/**\n * @since 1.0.0\n */\nexports.getFirstSemigroup = function () {\n    return { concat: function_1.identity };\n};\n/**\n * @since 1.0.0\n */\nexports.getLastSemigroup = function () {\n    return { concat: function (_, y) { return y; } };\n};\n/**\n * Given a tuple of semigroups returns a semigroup for the tuple\n *\n * @example\n * import { getTupleSemigroup, semigroupString, semigroupSum, semigroupAll } from 'fp-ts/lib/Semigroup'\n *\n * const S1 = getTupleSemigroup(semigroupString, semigroupSum)\n * assert.deepStrictEqual(S1.concat(['a', 1], ['b', 2]), ['ab', 3])\n *\n * const S2 = getTupleSemigroup(semigroupString, semigroupSum, semigroupAll)\n * assert.deepStrictEqual(S2.concat(['a', 1, true], ['b', 2, false]), ['ab', 3, false])\n *\n * @since 1.14.0\n */\nexports.getTupleSemigroup = function () {\n    var semigroups = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        semigroups[_i] = arguments[_i];\n    }\n    return {\n        concat: function (x, y) { return semigroups.map(function (s, i) { return s.concat(x[i], y[i]); }); }\n    };\n};\n/**\n * Use `getTupleSemigroup` instead\n * @since 1.0.0\n * @deprecated\n */\nexports.getProductSemigroup = function (SA, SB) {\n    return exports.getTupleSemigroup(SA, SB);\n};\n/**\n * @since 1.0.0\n */\nexports.getDualSemigroup = function (S) {\n    return {\n        concat: function (x, y) { return S.concat(y, x); }\n    };\n};\n/**\n * @since 1.0.0\n */\nexports.getFunctionSemigroup = function (S) { return function () {\n    return {\n        concat: function (f, g) { return function (a) { return S.concat(f(a), g(a)); }; }\n    };\n}; };\n/**\n * @since 1.14.0\n */\nexports.getStructSemigroup = function (semigroups) {\n    return {\n        concat: function (x, y) {\n            var r = {};\n            for (var _i = 0, _a = Object.keys(semigroups); _i < _a.length; _i++) {\n                var key = _a[_i];\n                r[key] = semigroups[key].concat(x[key], y[key]);\n            }\n            return r;\n        }\n    };\n};\n/**\n * Use `getStructSemigroup` instead\n * @since 1.0.0\n * @deprecated\n */\nexports.getRecordSemigroup = function (semigroups) {\n    return exports.getStructSemigroup(semigroups);\n};\n/**\n * @since 1.0.0\n */\nexports.getMeetSemigroup = function (O) {\n    return {\n        concat: Ord_1.min(O)\n    };\n};\n/**\n * @since 1.0.0\n */\nexports.getJoinSemigroup = function (O) {\n    return {\n        concat: Ord_1.max(O)\n    };\n};\n/**\n * Boolean semigroup under conjunction\n * @since 1.0.0\n */\nexports.semigroupAll = {\n    concat: function (x, y) { return x && y; }\n};\n/**\n * Boolean semigroup under disjunction\n * @since 1.0.0\n */\nexports.semigroupAny = {\n    concat: function (x, y) { return x || y; }\n};\n/**\n * Use `Monoid`'s `getArrayMonoid` instead\n * @since 1.0.0\n * @deprecated\n */\nexports.getArraySemigroup = function () {\n    return { concat: function_1.concat };\n};\nfunction getDictionarySemigroup(S) {\n    return {\n        concat: function (x, y) {\n            var r = __assign({}, x);\n            var keys = Object.keys(y);\n            var len = keys.length;\n            for (var i = 0; i < len; i++) {\n                var k = keys[i];\n                r[k] = x.hasOwnProperty(k) ? S.concat(x[k], y[k]) : y[k];\n            }\n            return r;\n        }\n    };\n}\nexports.getDictionarySemigroup = getDictionarySemigroup;\n// tslint:disable-next-line: deprecation\nvar semigroupAnyDictionary = getDictionarySemigroup(exports.getLastSemigroup());\n/**\n * Returns a `Semigroup` instance for objects preserving their type\n *\n * @example\n * import { getObjectSemigroup } from 'fp-ts/lib/Semigroup'\n *\n * interface Person {\n *   name: string\n *   age: number\n * }\n *\n * const S = getObjectSemigroup<Person>()\n * assert.deepStrictEqual(S.concat({ name: 'name', age: 23 }, { name: 'name', age: 24 }), { name: 'name', age: 24 })\n *\n * @since 1.4.0\n */\nexports.getObjectSemigroup = function () {\n    return semigroupAnyDictionary;\n};\n/**\n * Number `Semigroup` under addition\n * @since 1.0.0\n */\nexports.semigroupSum = {\n    concat: function (x, y) { return x + y; }\n};\n/**\n * Number `Semigroup` under multiplication\n * @since 1.0.0\n */\nexports.semigroupProduct = {\n    concat: function (x, y) { return x * y; }\n};\n/**\n * @since 1.0.0\n */\nexports.semigroupString = {\n    concat: function (x, y) { return x + y; }\n};\n/**\n * @since 1.0.0\n */\nexports.semigroupVoid = {\n    concat: function () { return undefined; }\n};\n","\"use strict\";\n/**\n * @file The `Setoid` type class represents types which support decidable equality.\n *\n * Instances must satisfy the following laws:\n *\n * 1. Reflexivity: `S.equals(a, a) === true`\n * 2. Symmetry: `S.equals(a, b) === S.equals(b, a)`\n * 3. Transitivity: if `S.equals(a, b) === true` and `S.equals(b, c) === true`, then `S.equals(a, c) === true`\n *\n * See [Getting started with fp-ts: Setoid](https://dev.to/gcanti/getting-started-with-fp-ts-setoid-39f3)\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @since 1.14.0\n */\nexports.fromEquals = function (equals) {\n    return {\n        equals: function (x, y) { return x === y || equals(x, y); }\n    };\n};\n/**\n * @since 1.0.0\n */\nexports.strictEqual = function (a, b) {\n    return a === b;\n};\nvar setoidStrict = { equals: exports.strictEqual };\n/**\n * @since 1.0.0\n */\nexports.setoidString = setoidStrict;\n/**\n * @since 1.0.0\n */\nexports.setoidNumber = setoidStrict;\n/**\n * @since 1.0.0\n */\nexports.setoidBoolean = setoidStrict;\n/**\n * @since 1.0.0\n */\nexports.getArraySetoid = function (S) {\n    return exports.fromEquals(function (xs, ys) { return xs.length === ys.length && xs.every(function (x, i) { return S.equals(x, ys[i]); }); });\n};\n/**\n * @since 1.14.2\n */\nexports.getStructSetoid = function (setoids) {\n    return exports.fromEquals(function (x, y) {\n        for (var k in setoids) {\n            if (!setoids[k].equals(x[k], y[k])) {\n                return false;\n            }\n        }\n        return true;\n    });\n};\n/**\n * Use `getStructSetoid` instead\n * @since 1.0.0\n * @deprecated\n */\nexports.getRecordSetoid = function (setoids) {\n    return exports.getStructSetoid(setoids);\n};\n/**\n * Given a tuple of `Setoid`s returns a `Setoid` for the tuple\n *\n * @example\n * import { getTupleSetoid, setoidString, setoidNumber, setoidBoolean } from 'fp-ts/lib/Setoid'\n *\n * const S = getTupleSetoid(setoidString, setoidNumber, setoidBoolean)\n * assert.strictEqual(S.equals(['a', 1, true], ['a', 1, true]), true)\n * assert.strictEqual(S.equals(['a', 1, true], ['b', 1, true]), false)\n * assert.strictEqual(S.equals(['a', 1, true], ['a', 2, true]), false)\n * assert.strictEqual(S.equals(['a', 1, true], ['a', 1, false]), false)\n *\n * @since 1.14.2\n */\nexports.getTupleSetoid = function () {\n    var setoids = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        setoids[_i] = arguments[_i];\n    }\n    return exports.fromEquals(function (x, y) { return setoids.every(function (S, i) { return S.equals(x[i], y[i]); }); });\n};\n/**\n * Use `getTupleSetoid` instead\n * @since 1.0.0\n * @deprecated\n */\nexports.getProductSetoid = function (SA, SB) {\n    return exports.getTupleSetoid(SA, SB);\n};\n/**\n * Returns the `Setoid` corresponding to the partitions of `B` induced by `f`\n *\n * @since 1.2.0\n */\nexports.contramap = function (f, fa) {\n    return exports.fromEquals(function (x, y) { return fa.equals(f(x), f(y)); });\n};\n/**\n * @since 1.4.0\n */\nexports.setoidDate = exports.contramap(function (date) { return date.valueOf(); }, exports.setoidNumber);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @since 1.0.0\n */\nexports.identity = function (a) {\n    return a;\n};\n/**\n * @since 1.0.0\n */\nexports.unsafeCoerce = exports.identity;\n/**\n * @since 1.0.0\n */\nexports.not = function (predicate) {\n    return function (a) { return !predicate(a); };\n};\nfunction or(p1, p2) {\n    return function (a) { return p1(a) || p2(a); };\n}\nexports.or = or;\n/**\n * @since 1.0.0\n */\nexports.and = function (p1, p2) {\n    return function (a) { return p1(a) && p2(a); };\n};\n/**\n * @since 1.0.0\n */\nexports.constant = function (a) {\n    return function () { return a; };\n};\n/**\n * A thunk that returns always `true`\n *\n * @since 1.0.0\n */\nexports.constTrue = function () {\n    return true;\n};\n/**\n * A thunk that returns always `false`\n *\n * @since 1.0.0\n */\nexports.constFalse = function () {\n    return false;\n};\n/**\n * A thunk that returns always `null`\n *\n * @since 1.0.0\n */\nexports.constNull = function () {\n    return null;\n};\n/**\n * A thunk that returns always `undefined`\n *\n * @since 1.0.0\n */\nexports.constUndefined = function () {\n    return;\n};\n/**\n * A thunk that returns always `void`\n *\n * @since 1.14.0\n */\nexports.constVoid = function () {\n    return;\n};\n/**\n * Flips the order of the arguments to a function of two arguments.\n *\n * @since 1.0.0\n */\nexports.flip = function (f) {\n    return function (b) { return function (a) { return f(a)(b); }; };\n};\n/**\n * The `on` function is used to change the domain of a binary operator.\n *\n * @since 1.0.0\n */\nexports.on = function (op) { return function (f) {\n    return function (x, y) { return op(f(x), f(y)); };\n}; };\nfunction compose() {\n    var fns = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        fns[_i] = arguments[_i];\n    }\n    var len = fns.length - 1;\n    return function (x) {\n        var y = x;\n        for (var i = len; i > -1; i--) {\n            y = fns[i].call(this, y);\n        }\n        return y;\n    };\n}\nexports.compose = compose;\nfunction pipe() {\n    var fns = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        fns[_i] = arguments[_i];\n    }\n    var len = fns.length - 1;\n    return function (x) {\n        var y = x;\n        for (var i = 0; i <= len; i++) {\n            y = fns[i].call(this, y);\n        }\n        return y;\n    };\n}\nexports.pipe = pipe;\n/**\n * @since 1.0.0\n */\nexports.concat = function (x, y) {\n    var lenx = x.length;\n    if (lenx === 0) {\n        return y;\n    }\n    var leny = y.length;\n    if (leny === 0) {\n        return x;\n    }\n    var r = Array(lenx + leny);\n    for (var i = 0; i < lenx; i++) {\n        r[i] = x[i];\n    }\n    for (var i = 0; i < leny; i++) {\n        r[i + lenx] = y[i];\n    }\n    return r;\n};\n/**\n * @since 1.0.0\n */\nfunction curried(f, n, acc) {\n    return function (x) {\n        var combined = exports.concat(acc, [x]);\n        return n === 0 ? f.apply(this, combined) : curried(f, n - 1, combined);\n    };\n}\nexports.curried = curried;\nfunction curry(f) {\n    return curried(f, f.length - 1, []);\n}\nexports.curry = curry;\n/* tslint:disable-next-line */\nvar getFunctionName = function (f) { return f.displayName || f.name || \"<function\" + f.length + \">\"; };\n/**\n * @since 1.0.0\n */\nexports.toString = function (x) {\n    if (typeof x === 'string') {\n        return JSON.stringify(x);\n    }\n    if (x instanceof Date) {\n        return \"new Date('\" + x.toISOString() + \"')\";\n    }\n    if (Array.isArray(x)) {\n        return \"[\" + x.map(exports.toString).join(', ') + \"]\";\n    }\n    if (typeof x === 'function') {\n        return getFunctionName(x);\n    }\n    if (x == null) {\n        return String(x);\n    }\n    if (typeof x.toString === 'function' && x.toString !== Object.prototype.toString) {\n        return x.toString();\n    }\n    try {\n        return JSON.stringify(x, null, 2);\n    }\n    catch (e) {\n        return String(x);\n    }\n};\n/**\n * @since 1.0.0\n */\nexports.tuple = function () {\n    var t = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        t[_i] = arguments[_i];\n    }\n    return t;\n};\n/**\n * @since 1.0.0\n * @deprecated\n */\nexports.tupleCurried = function (a) { return function (b) {\n    return [a, b];\n}; };\n/**\n * Applies a function to an argument ($)\n *\n * @since 1.0.0\n */\nexports.apply = function (f) { return function (a) {\n    return f(a);\n}; };\n/**\n * Applies an argument to a function (#)\n *\n * @since 1.0.0\n */\nexports.applyFlipped = function (a) { return function (f) {\n    return f(a);\n}; };\n/**\n * For use with phantom fields\n *\n * @since 1.0.0\n */\nexports.phantom = undefined;\n/**\n * A thunk that returns always the `identity` function.\n * For use with `applySecond` methods.\n *\n * @since 1.5.0\n */\nexports.constIdentity = function () {\n    return exports.identity;\n};\n/**\n * @since 1.9.0\n */\nexports.increment = function (n) {\n    return n + 1;\n};\n/**\n * @since 1.9.0\n */\nexports.decrement = function (n) {\n    return n - 1;\n};\n/**\n * @since 1.18.0\n */\nfunction absurd(_) {\n    throw new Error('Called `absurd` function which should be uncallable');\n}\nexports.absurd = absurd;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar array = require(\"fp-ts/lib/Array\");\n/* tslint:enable no-unused-variable */\nvar jsToString = function (value) { return (value === undefined ? 'undefined' : JSON.stringify(value)); };\nexports.formatValidationError = function (error) {\n    var path = error.context\n        .map(function (c) { return c.key; })\n        .filter(function (key) { return key.length > 0; })\n        .join('.');\n    // The actual error is last in context\n    var maybeErrorContext = array.last(\n    // https://github.com/gcanti/fp-ts/pull/544/files\n    error.context);\n    return maybeErrorContext.map(function (errorContext) {\n        var expectedType = errorContext.type.name;\n        return (\n        // https://github.com/elm-lang/core/blob/18c9e84e975ed22649888bfad15d1efdb0128ab2/src/Native/Json.js#L199\n        // tslint:disable-next-line:prefer-template\n        \"Expecting \" + expectedType\n            + (path === '' ? '' : \" at \" + path)\n            + (\" but instead got: \" + jsToString(error.value) + \".\"));\n    });\n};\nexports.reporter = function (validation) { return (validation.fold(function (errors) { return array.catOptions(errors.map(exports.formatValidationError)); }, function () { return []; })); };\n//# sourceMappingURL=index.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { Left, Right } from 'fp-ts/lib/Either';\n/**\n * @since 1.0.0\n */\nvar Type = /** @class */ (function () {\n    function Type(\n    /** a unique name for this codec */\n    name, \n    /** a custom type guard */\n    is, \n    /** succeeds if a value of type I can be decoded to a value of type A */\n    validate, \n    /** converts a value of type A to a value of type O */\n    encode) {\n        this.name = name;\n        this.is = is;\n        this.validate = validate;\n        this.encode = encode;\n        this.decode = this.decode.bind(this);\n    }\n    Type.prototype.pipe = function (ab, name) {\n        var _this = this;\n        if (name === void 0) { name = \"pipe(\" + this.name + \", \" + ab.name + \")\"; }\n        return new Type(name, ab.is, function (i, c) {\n            var validation = _this.validate(i, c);\n            if (validation.isLeft()) {\n                return validation;\n            }\n            return ab.validate(validation.value, c);\n        }, this.encode === identity && ab.encode === identity ? identity : function (b) { return _this.encode(ab.encode(b)); });\n    };\n    Type.prototype.asDecoder = function () {\n        return this;\n    };\n    Type.prototype.asEncoder = function () {\n        return this;\n    };\n    /** a version of `validate` with a default context */\n    Type.prototype.decode = function (i) {\n        return this.validate(i, [{ key: '', type: this, actual: i }]);\n    };\n    return Type;\n}());\nexport { Type };\n/**\n * @since 1.0.0\n */\nexport var identity = function (a) { return a; };\n/**\n * @since 1.0.0\n */\nexport var getFunctionName = function (f) {\n    return f.displayName || f.name || \"<function\" + f.length + \">\";\n};\n/**\n * @since 1.0.0\n */\nexport var getContextEntry = function (key, decoder) { return ({ key: key, type: decoder }); };\n/**\n * @since 1.0.0\n */\nexport var appendContext = function (c, key, decoder, actual) {\n    var len = c.length;\n    var r = Array(len + 1);\n    for (var i = 0; i < len; i++) {\n        r[i] = c[i];\n    }\n    r[len] = { key: key, type: decoder, actual: actual };\n    return r;\n};\n/**\n * @since 1.0.0\n */\nexport var failures = function (errors) { return new Left(errors); };\n/**\n * @since 1.0.0\n */\nexport var failure = function (value, context, message) {\n    return failures([{ value: value, context: context, message: message }]);\n};\n/**\n * @since 1.0.0\n */\nexport var success = function (value) { return new Right(value); };\nvar pushAll = function (xs, ys) {\n    var l = ys.length;\n    for (var i = 0; i < l; i++) {\n        xs.push(ys[i]);\n    }\n};\nvar getIsCodec = function (tag) { return function (codec) { return codec._tag === tag; }; };\nvar isUnknownCodec = getIsCodec('UnknownType');\nvar isAnyCodec = getIsCodec('AnyType');\nvar isLiteralCodec = getIsCodec('LiteralType');\nvar isInterfaceCodec = getIsCodec('InterfaceType');\nvar isPartialCodec = getIsCodec('PartialType');\nvar isStrictCodec = getIsCodec('StrictType');\nvar isIntersectionCodec = getIsCodec('IntersectionType');\nvar isUnionCodec = getIsCodec('UnionType');\nvar isExactCodec = getIsCodec('ExactType');\nvar isRefinementCodec = getIsCodec('RefinementType');\nvar isRecursiveCodec = getIsCodec('RecursiveType');\n//\n// basic types\n//\n/**\n * @since 1.0.0\n */\nvar NullType = /** @class */ (function (_super) {\n    __extends(NullType, _super);\n    function NullType() {\n        var _this = _super.call(this, 'null', function (u) { return u === null; }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, identity) || this;\n        _this._tag = 'NullType';\n        return _this;\n    }\n    return NullType;\n}(Type));\nexport { NullType };\n/**\n * @alias `null`\n * @since 1.0.0\n */\nexport var nullType = new NullType();\n/**\n * @since 1.0.0\n */\nvar UndefinedType = /** @class */ (function (_super) {\n    __extends(UndefinedType, _super);\n    function UndefinedType() {\n        var _this = _super.call(this, 'undefined', function (u) { return u === void 0; }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, identity) || this;\n        _this._tag = 'UndefinedType';\n        return _this;\n    }\n    return UndefinedType;\n}(Type));\nexport { UndefinedType };\nvar undefinedType = new UndefinedType();\n/**\n * @since 1.2.0\n */\nvar VoidType = /** @class */ (function (_super) {\n    __extends(VoidType, _super);\n    function VoidType() {\n        var _this = _super.call(this, 'void', undefinedType.is, undefinedType.validate, identity) || this;\n        _this._tag = 'VoidType';\n        return _this;\n    }\n    return VoidType;\n}(Type));\nexport { VoidType };\n/**\n * @alias `void`\n * @since 1.2.0\n */\nexport var voidType = new VoidType();\n/**\n * @since 1.5.0\n */\nvar UnknownType = /** @class */ (function (_super) {\n    __extends(UnknownType, _super);\n    function UnknownType() {\n        var _this = _super.call(this, 'unknown', function (_) { return true; }, success, identity) || this;\n        _this._tag = 'UnknownType';\n        return _this;\n    }\n    return UnknownType;\n}(Type));\nexport { UnknownType };\n/**\n * @since 1.5.0\n */\nexport var unknown = new UnknownType();\n/**\n * @since 1.0.0\n */\nvar StringType = /** @class */ (function (_super) {\n    __extends(StringType, _super);\n    function StringType() {\n        var _this = _super.call(this, 'string', function (u) { return typeof u === 'string'; }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, identity) || this;\n        _this._tag = 'StringType';\n        return _this;\n    }\n    return StringType;\n}(Type));\nexport { StringType };\n/**\n * @since 1.0.0\n */\nexport var string = new StringType();\n/**\n * @since 1.0.0\n */\nvar NumberType = /** @class */ (function (_super) {\n    __extends(NumberType, _super);\n    function NumberType() {\n        var _this = _super.call(this, 'number', function (u) { return typeof u === 'number'; }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, identity) || this;\n        _this._tag = 'NumberType';\n        return _this;\n    }\n    return NumberType;\n}(Type));\nexport { NumberType };\n/**\n * @since 1.0.0\n */\nexport var number = new NumberType();\n/**\n * @since 1.0.0\n */\nvar BooleanType = /** @class */ (function (_super) {\n    __extends(BooleanType, _super);\n    function BooleanType() {\n        var _this = _super.call(this, 'boolean', function (u) { return typeof u === 'boolean'; }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, identity) || this;\n        _this._tag = 'BooleanType';\n        return _this;\n    }\n    return BooleanType;\n}(Type));\nexport { BooleanType };\n/**\n * @since 1.0.0\n */\nexport var boolean = new BooleanType();\n/**\n * @since 1.0.0\n */\nvar AnyArrayType = /** @class */ (function (_super) {\n    __extends(AnyArrayType, _super);\n    function AnyArrayType() {\n        var _this = _super.call(this, 'UnknownArray', Array.isArray, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, identity) || this;\n        _this._tag = 'AnyArrayType';\n        return _this;\n    }\n    return AnyArrayType;\n}(Type));\nexport { AnyArrayType };\n/**\n * @since 1.7.1\n */\nexport var UnknownArray = new AnyArrayType();\n/**\n * @since 1.0.0\n */\nvar AnyDictionaryType = /** @class */ (function (_super) {\n    __extends(AnyDictionaryType, _super);\n    function AnyDictionaryType() {\n        var _this = _super.call(this, 'UnknownRecord', function (u) { return u !== null && typeof u === 'object'; }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, identity) || this;\n        _this._tag = 'AnyDictionaryType';\n        return _this;\n    }\n    return AnyDictionaryType;\n}(Type));\nexport { AnyDictionaryType };\n/**\n * @since 1.7.1\n */\nexport var UnknownRecord = new AnyDictionaryType();\n/**\n * @since 1.0.0\n * @deprecated\n */\nvar FunctionType = /** @class */ (function (_super) {\n    __extends(FunctionType, _super);\n    function FunctionType() {\n        var _this = _super.call(this, 'Function', \n        // tslint:disable-next-line:strict-type-predicates\n        function (u) { return typeof u === 'function'; }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, identity) || this;\n        _this._tag = 'FunctionType';\n        return _this;\n    }\n    return FunctionType;\n}(Type));\nexport { FunctionType };\n/**\n * @since 1.0.0\n * @deprecated\n */\nexport var Function = new FunctionType();\n/**\n * @since 1.0.0\n */\nvar RefinementType = /** @class */ (function (_super) {\n    __extends(RefinementType, _super);\n    function RefinementType(name, is, validate, encode, type, predicate) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.type = type;\n        _this.predicate = predicate;\n        _this._tag = 'RefinementType';\n        return _this;\n    }\n    return RefinementType;\n}(Type));\nexport { RefinementType };\n/**\n * @since 1.8.1\n */\nexport var brand = function (codec, predicate, name) {\n    return refinement(codec, predicate, name);\n};\n/**\n * A branded codec representing an integer\n * @since 1.8.1\n */\nexport var Int = brand(number, function (n) { return Number.isInteger(n); }, 'Int');\n/**\n * @since 1.0.0\n */\nvar LiteralType = /** @class */ (function (_super) {\n    __extends(LiteralType, _super);\n    function LiteralType(name, is, validate, encode, value) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.value = value;\n        _this._tag = 'LiteralType';\n        return _this;\n    }\n    return LiteralType;\n}(Type));\nexport { LiteralType };\n/**\n * @since 1.0.0\n */\nexport var literal = function (value, name) {\n    if (name === void 0) { name = JSON.stringify(value); }\n    var is = function (u) { return u === value; };\n    return new LiteralType(name, is, function (u, c) { return (is(u) ? success(value) : failure(u, c)); }, identity, value);\n};\n/**\n * @since 1.0.0\n */\nvar KeyofType = /** @class */ (function (_super) {\n    __extends(KeyofType, _super);\n    function KeyofType(name, is, validate, encode, keys) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.keys = keys;\n        _this._tag = 'KeyofType';\n        return _this;\n    }\n    return KeyofType;\n}(Type));\nexport { KeyofType };\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n/**\n * @since 1.0.0\n */\nexport var keyof = function (keys, name) {\n    if (name === void 0) { name = Object.keys(keys)\n        .map(function (k) { return JSON.stringify(k); })\n        .join(' | '); }\n    var is = function (u) { return string.is(u) && hasOwnProperty.call(keys, u); };\n    return new KeyofType(name, is, function (u, c) { return (is(u) ? success(u) : failure(u, c)); }, identity, keys);\n};\n/**\n * @since 1.0.0\n */\nvar RecursiveType = /** @class */ (function (_super) {\n    __extends(RecursiveType, _super);\n    function RecursiveType(name, is, validate, encode, runDefinition) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.runDefinition = runDefinition;\n        _this._tag = 'RecursiveType';\n        return _this;\n    }\n    Object.defineProperty(RecursiveType.prototype, \"type\", {\n        get: function () {\n            return this.runDefinition();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return RecursiveType;\n}(Type));\nexport { RecursiveType };\n/**\n * @since 1.0.0\n */\nexport var recursion = function (name, definition) {\n    var cache;\n    var runDefinition = function () {\n        if (!cache) {\n            cache = definition(Self);\n            cache.name = name;\n        }\n        return cache;\n    };\n    var Self = new RecursiveType(name, function (u) { return runDefinition().is(u); }, function (u, c) { return runDefinition().validate(u, c); }, function (a) { return runDefinition().encode(a); }, runDefinition);\n    var indexRecordCache;\n    Self.getIndexRecord = function () {\n        if (!indexRecordCache) {\n            isRecursiveCodecIndexable = false;\n            indexRecordCache = getCodecIndexRecord(definition(Self), Self, Self);\n            isRecursiveCodecIndexable = true;\n        }\n        return indexRecordCache;\n    };\n    return Self;\n};\n/**\n * @since 1.0.0\n */\nvar ArrayType = /** @class */ (function (_super) {\n    __extends(ArrayType, _super);\n    function ArrayType(name, is, validate, encode, type) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.type = type;\n        _this._tag = 'ArrayType';\n        return _this;\n    }\n    return ArrayType;\n}(Type));\nexport { ArrayType };\n/**\n * @since 1.0.0\n */\nexport var array = function (codec, name) {\n    if (name === void 0) { name = \"Array<\" + codec.name + \">\"; }\n    return new ArrayType(name, function (u) { return UnknownArray.is(u) && u.every(codec.is); }, function (u, c) {\n        var unknownArrayValidation = UnknownArray.validate(u, c);\n        if (unknownArrayValidation.isLeft()) {\n            return unknownArrayValidation;\n        }\n        var us = unknownArrayValidation.value;\n        var len = us.length;\n        var as = us;\n        var errors = [];\n        for (var i = 0; i < len; i++) {\n            var ui = us[i];\n            var validation = codec.validate(ui, appendContext(c, String(i), codec, ui));\n            if (validation.isLeft()) {\n                pushAll(errors, validation.value);\n            }\n            else {\n                var ai = validation.value;\n                if (ai !== ui) {\n                    if (as === us) {\n                        as = us.slice();\n                    }\n                    as[i] = ai;\n                }\n            }\n        }\n        return errors.length > 0 ? failures(errors) : success(as);\n    }, codec.encode === identity ? identity : function (a) { return a.map(codec.encode); }, codec);\n};\n/**\n * @since 1.0.0\n */\nvar InterfaceType = /** @class */ (function (_super) {\n    __extends(InterfaceType, _super);\n    function InterfaceType(name, is, validate, encode, props) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.props = props;\n        _this._tag = 'InterfaceType';\n        return _this;\n    }\n    return InterfaceType;\n}(Type));\nexport { InterfaceType };\nvar getNameFromProps = function (props) {\n    return Object.keys(props)\n        .map(function (k) { return k + \": \" + props[k].name; })\n        .join(', ');\n};\nvar useIdentity = function (codecs, len) {\n    for (var i = 0; i < len; i++) {\n        if (codecs[i].encode !== identity) {\n            return false;\n        }\n    }\n    return true;\n};\nvar getInterfaceTypeName = function (props) {\n    return \"{ \" + getNameFromProps(props) + \" }\";\n};\n/**\n * @alias `interface`\n * @since 1.0.0\n */\nexport var type = function (props, name) {\n    if (name === void 0) { name = getInterfaceTypeName(props); }\n    var keys = Object.keys(props);\n    var types = keys.map(function (key) { return props[key]; });\n    var len = keys.length;\n    return new InterfaceType(name, function (u) {\n        if (!UnknownRecord.is(u)) {\n            return false;\n        }\n        for (var i = 0; i < len; i++) {\n            var k = keys[i];\n            if (!hasOwnProperty.call(u, k) || !types[i].is(u[k])) {\n                return false;\n            }\n        }\n        return true;\n    }, function (u, c) {\n        var unknownRecordValidation = UnknownRecord.validate(u, c);\n        if (unknownRecordValidation.isLeft()) {\n            return unknownRecordValidation;\n        }\n        var o = unknownRecordValidation.value;\n        var a = o;\n        var errors = [];\n        for (var i = 0; i < len; i++) {\n            var k = keys[i];\n            if (!hasOwnProperty.call(a, k)) {\n                if (a === o) {\n                    a = __assign({}, o);\n                }\n                a[k] = a[k];\n            }\n            var ak = a[k];\n            var type_1 = types[i];\n            var validation = type_1.validate(ak, appendContext(c, k, type_1, ak));\n            if (validation.isLeft()) {\n                pushAll(errors, validation.value);\n            }\n            else {\n                var vak = validation.value;\n                if (vak !== ak) {\n                    /* istanbul ignore next */\n                    if (a === o) {\n                        a = __assign({}, o);\n                    }\n                    a[k] = vak;\n                }\n            }\n        }\n        return errors.length > 0 ? failures(errors) : success(a);\n    }, useIdentity(types, len)\n        ? identity\n        : function (a) {\n            var s = __assign({}, a);\n            for (var i = 0; i < len; i++) {\n                var k = keys[i];\n                var encode = types[i].encode;\n                if (encode !== identity) {\n                    s[k] = encode(a[k]);\n                }\n            }\n            return s;\n        }, props);\n};\n/**\n * @since 1.0.0\n */\nvar PartialType = /** @class */ (function (_super) {\n    __extends(PartialType, _super);\n    function PartialType(name, is, validate, encode, props) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.props = props;\n        _this._tag = 'PartialType';\n        return _this;\n    }\n    return PartialType;\n}(Type));\nexport { PartialType };\nvar getPartialTypeName = function (inner) {\n    return \"Partial<\" + inner + \">\";\n};\n/**\n * @since 1.0.0\n */\nexport var partial = function (props, name) {\n    if (name === void 0) { name = getPartialTypeName(getInterfaceTypeName(props)); }\n    var keys = Object.keys(props);\n    var types = keys.map(function (key) { return props[key]; });\n    var len = keys.length;\n    return new PartialType(name, function (u) {\n        if (!UnknownRecord.is(u)) {\n            return false;\n        }\n        for (var i = 0; i < len; i++) {\n            var k = keys[i];\n            var uk = u[k];\n            if (uk !== undefined && !props[k].is(uk)) {\n                return false;\n            }\n        }\n        return true;\n    }, function (u, c) {\n        var unknownRecordValidation = UnknownRecord.validate(u, c);\n        if (unknownRecordValidation.isLeft()) {\n            return unknownRecordValidation;\n        }\n        var o = unknownRecordValidation.value;\n        var a = o;\n        var errors = [];\n        for (var i = 0; i < len; i++) {\n            var k = keys[i];\n            var ak = a[k];\n            var type_2 = props[k];\n            var validation = type_2.validate(ak, appendContext(c, k, type_2, ak));\n            if (validation.isLeft() && ak !== undefined) {\n                pushAll(errors, validation.value);\n            }\n            else if (validation.isRight()) {\n                var vak = validation.value;\n                if (vak !== ak) {\n                    /* istanbul ignore next */\n                    if (a === o) {\n                        a = __assign({}, o);\n                    }\n                    a[k] = vak;\n                }\n            }\n        }\n        return errors.length > 0 ? failures(errors) : success(a);\n    }, useIdentity(types, len)\n        ? identity\n        : function (a) {\n            var s = __assign({}, a);\n            for (var i = 0; i < len; i++) {\n                var k = keys[i];\n                var ak = a[k];\n                if (ak !== undefined) {\n                    s[k] = types[i].encode(ak);\n                }\n            }\n            return s;\n        }, props);\n};\n/**\n * @since 1.0.0\n */\nvar DictionaryType = /** @class */ (function (_super) {\n    __extends(DictionaryType, _super);\n    function DictionaryType(name, is, validate, encode, domain, codomain) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.domain = domain;\n        _this.codomain = codomain;\n        _this._tag = 'DictionaryType';\n        return _this;\n    }\n    return DictionaryType;\n}(Type));\nexport { DictionaryType };\nvar isObject = function (r) { return Object.prototype.toString.call(r) === '[object Object]'; };\n/**\n * @since 1.7.1\n */\nexport var record = function (domain, codomain, name) {\n    if (name === void 0) { name = \"{ [K in \" + domain.name + \"]: \" + codomain.name + \" }\"; }\n    return new DictionaryType(name, function (u) {\n        if (!UnknownRecord.is(u)) {\n            return false;\n        }\n        if (!isUnknownCodec(codomain) && !isAnyCodec(codomain) && !isObject(u)) {\n            return false;\n        }\n        return Object.keys(u).every(function (k) { return domain.is(k) && codomain.is(u[k]); });\n    }, function (u, c) {\n        var unknownRecordValidation = UnknownRecord.validate(u, c);\n        if (unknownRecordValidation.isLeft()) {\n            return unknownRecordValidation;\n        }\n        var o = unknownRecordValidation.value;\n        if (!isUnknownCodec(codomain) && !isAnyCodec(codomain) && !isObject(o)) {\n            return failure(u, c);\n        }\n        var a = {};\n        var errors = [];\n        var keys = Object.keys(o);\n        var len = keys.length;\n        var changed = false;\n        for (var i = 0; i < len; i++) {\n            var k = keys[i];\n            var ok = o[k];\n            var domainValidation = domain.validate(k, appendContext(c, k, domain, k));\n            if (domainValidation.isLeft()) {\n                pushAll(errors, domainValidation.value);\n            }\n            else {\n                var vk = domainValidation.value;\n                changed = changed || vk !== k;\n                k = vk;\n                var codomainValidation = codomain.validate(ok, appendContext(c, k, codomain, ok));\n                if (codomainValidation.isLeft()) {\n                    pushAll(errors, codomainValidation.value);\n                }\n                else {\n                    var vok = codomainValidation.value;\n                    changed = changed || vok !== ok;\n                    a[k] = vok;\n                }\n            }\n        }\n        return errors.length > 0 ? failures(errors) : success((changed ? a : o));\n    }, domain.encode === identity && codomain.encode === identity\n        ? identity\n        : function (a) {\n            var s = {};\n            var keys = Object.keys(a);\n            var len = keys.length;\n            for (var i = 0; i < len; i++) {\n                var k = keys[i];\n                s[String(domain.encode(k))] = codomain.encode(a[k]);\n            }\n            return s;\n        }, domain, codomain);\n};\n/**\n * @since 1.0.0\n */\nvar UnionType = /** @class */ (function (_super) {\n    __extends(UnionType, _super);\n    function UnionType(name, is, validate, encode, types) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.types = types;\n        _this._tag = 'UnionType';\n        return _this;\n    }\n    return UnionType;\n}(Type));\nexport { UnionType };\nvar getUnionName = function (codecs) {\n    return '(' + codecs.map(function (type) { return type.name; }).join(' | ') + ')';\n};\n/**\n * @since 1.0.0\n */\nexport var union = function (codecs, name) {\n    if (name === void 0) { name = getUnionName(codecs); }\n    var len = codecs.length;\n    return new UnionType(name, function (u) { return codecs.some(function (type) { return type.is(u); }); }, function (u, c) {\n        var errors = [];\n        for (var i = 0; i < len; i++) {\n            var type_3 = codecs[i];\n            var validation = type_3.validate(u, appendContext(c, String(i), type_3, u));\n            if (validation.isRight()) {\n                return validation;\n            }\n            pushAll(errors, validation.value);\n        }\n        return errors.length > 0 ? failures(errors) : failure(u, c);\n    }, useIdentity(codecs, len)\n        ? identity\n        : function (a) {\n            for (var i = 0; i < len; i++) {\n                var codec = codecs[i];\n                if (codec.is(a)) {\n                    return codec.encode(a);\n                }\n            }\n            // https://github.com/gcanti/io-ts/pull/305\n            throw new Error(\"no codec found to encode value in union type \" + name);\n        }, codecs);\n};\n/**\n * @since 1.0.0\n */\nvar IntersectionType = /** @class */ (function (_super) {\n    __extends(IntersectionType, _super);\n    function IntersectionType(name, is, validate, encode, types) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.types = types;\n        _this._tag = 'IntersectionType';\n        return _this;\n    }\n    return IntersectionType;\n}(Type));\nexport { IntersectionType };\nvar mergeAll = function (base, us) {\n    var r = base;\n    for (var i = 0; i < us.length; i++) {\n        var u = us[i];\n        if (u !== base) {\n            // `u` contains a prismatic value or is the result of a stripping combinator\n            if (r === base) {\n                r = Object.assign({}, u);\n                continue;\n            }\n            for (var k in u) {\n                if (u[k] !== base[k] || !r.hasOwnProperty(k)) {\n                    r[k] = u[k];\n                }\n            }\n        }\n    }\n    return r;\n};\nexport function intersection(codecs, name) {\n    if (name === void 0) { name = \"(\" + codecs.map(function (type) { return type.name; }).join(' & ') + \")\"; }\n    var len = codecs.length;\n    return new IntersectionType(name, function (u) { return codecs.every(function (type) { return type.is(u); }); }, codecs.length === 0\n        ? success\n        : function (u, c) {\n            var us = [];\n            var errors = [];\n            for (var i = 0; i < len; i++) {\n                var codec = codecs[i];\n                var validation = codec.validate(u, appendContext(c, String(i), codec, u));\n                if (validation.isLeft()) {\n                    pushAll(errors, validation.value);\n                }\n                else {\n                    us.push(validation.value);\n                }\n            }\n            return errors.length > 0 ? failures(errors) : success(mergeAll(u, us));\n        }, codecs.length === 0 ? identity : function (a) { return mergeAll(a, codecs.map(function (codec) { return codec.encode(a); })); }, codecs);\n}\n/**\n * @since 1.0.0\n */\nvar TupleType = /** @class */ (function (_super) {\n    __extends(TupleType, _super);\n    function TupleType(name, is, validate, encode, types) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.types = types;\n        _this._tag = 'TupleType';\n        return _this;\n    }\n    return TupleType;\n}(Type));\nexport { TupleType };\nexport function tuple(codecs, name) {\n    if (name === void 0) { name = \"[\" + codecs.map(function (type) { return type.name; }).join(', ') + \"]\"; }\n    var len = codecs.length;\n    return new TupleType(name, function (u) { return UnknownArray.is(u) && u.length === len && codecs.every(function (type, i) { return type.is(u[i]); }); }, function (u, c) {\n        var unknownArrayValidation = UnknownArray.validate(u, c);\n        if (unknownArrayValidation.isLeft()) {\n            return unknownArrayValidation;\n        }\n        var us = unknownArrayValidation.value;\n        var as = us.length > len ? us.slice(0, len) : us; // strip additional components\n        var errors = [];\n        for (var i = 0; i < len; i++) {\n            var a = us[i];\n            var type_4 = codecs[i];\n            var validation = type_4.validate(a, appendContext(c, String(i), type_4, a));\n            if (validation.isLeft()) {\n                pushAll(errors, validation.value);\n            }\n            else {\n                var va = validation.value;\n                if (va !== a) {\n                    /* istanbul ignore next */\n                    if (as === us) {\n                        as = us.slice();\n                    }\n                    as[i] = va;\n                }\n            }\n        }\n        return errors.length > 0 ? failures(errors) : success(as);\n    }, useIdentity(codecs, len) ? identity : function (a) { return codecs.map(function (type, i) { return type.encode(a[i]); }); }, codecs);\n}\n/**\n * @since 1.0.0\n */\nvar ReadonlyType = /** @class */ (function (_super) {\n    __extends(ReadonlyType, _super);\n    function ReadonlyType(name, is, validate, encode, type) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.type = type;\n        _this._tag = 'ReadonlyType';\n        return _this;\n    }\n    return ReadonlyType;\n}(Type));\nexport { ReadonlyType };\n/**\n * @since 1.0.0\n */\nexport var readonly = function (codec, name) {\n    if (name === void 0) { name = \"Readonly<\" + codec.name + \">\"; }\n    return new ReadonlyType(name, codec.is, function (u, c) {\n        return codec.validate(u, c).map(function (x) {\n            if (process.env.NODE_ENV !== 'production') {\n                return Object.freeze(x);\n            }\n            return x;\n        });\n    }, codec.encode === identity ? identity : codec.encode, codec);\n};\n/**\n * @since 1.0.0\n */\nvar ReadonlyArrayType = /** @class */ (function (_super) {\n    __extends(ReadonlyArrayType, _super);\n    function ReadonlyArrayType(name, is, validate, encode, type) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.type = type;\n        _this._tag = 'ReadonlyArrayType';\n        return _this;\n    }\n    return ReadonlyArrayType;\n}(Type));\nexport { ReadonlyArrayType };\n/**\n * @since 1.0.0\n */\nexport var readonlyArray = function (codec, name) {\n    if (name === void 0) { name = \"ReadonlyArray<\" + codec.name + \">\"; }\n    var arrayType = array(codec);\n    return new ReadonlyArrayType(name, arrayType.is, function (u, c) {\n        return arrayType.validate(u, c).map(function (x) {\n            if (process.env.NODE_ENV !== 'production') {\n                return Object.freeze(x);\n            }\n            return x;\n        });\n    }, arrayType.encode, codec);\n};\n/**\n * Strips additional properties\n * @since 1.0.0\n */\nexport var strict = function (props, name) {\n    return exact(type(props), name);\n};\n/** @internal */\nexport var emptyIndexRecord = {};\nvar monoidIndexRecord = {\n    concat: function (a, b) {\n        var _a;\n        if (a === monoidIndexRecord.empty) {\n            return b;\n        }\n        if (b === monoidIndexRecord.empty) {\n            return a;\n        }\n        var r = cloneIndexRecord(a);\n        for (var k in b) {\n            if (r.hasOwnProperty(k)) {\n                (_a = r[k]).push.apply(_a, b[k]);\n            }\n            else {\n                r[k] = b[k];\n            }\n        }\n        return r;\n    },\n    empty: emptyIndexRecord\n};\nvar isIndexRecordEmpty = function (a) {\n    for (var _ in a) {\n        return false;\n    }\n    return true;\n};\nvar foldMapIndexRecord = function (as, f) {\n    return as.reduce(function (acc, a) { return monoidIndexRecord.concat(acc, f(a)); }, monoidIndexRecord.empty);\n};\nvar cloneIndexRecord = function (a) {\n    var r = {};\n    for (var k in a) {\n        r[k] = a[k].slice();\n    }\n    return r;\n};\nvar updateindexRecordOrigin = function (origin, indexRecord) {\n    var r = {};\n    for (var k in indexRecord) {\n        r[k] = indexRecord[k].map(function (_a) {\n            var v = _a[0], _ = _a[1], id = _a[2];\n            return [v, origin, id];\n        });\n    }\n    return r;\n};\nvar getCodecIndexRecord = function (codec, origin, id) {\n    if (isInterfaceCodec(codec) || isStrictCodec(codec)) {\n        var interfaceIndex = {};\n        for (var k in codec.props) {\n            var prop = codec.props[k];\n            if (isLiteralCodec(prop)) {\n                var value = prop.value;\n                interfaceIndex[k] = [[value, origin, id]];\n            }\n        }\n        return interfaceIndex;\n    }\n    if (isIntersectionCodec(codec)) {\n        return foldMapIndexRecord(codec.types, function (type) { return getCodecIndexRecord(type, origin, codec); });\n    }\n    if (isUnionCodec(codec)) {\n        return foldMapIndexRecord(codec.types, function (type) { return getCodecIndexRecord(type, origin, type); });\n    }\n    if (isExactCodec(codec) || isRefinementCodec(codec)) {\n        return getCodecIndexRecord(codec.type, origin, codec);\n    }\n    if (isRecursiveCodec(codec)) {\n        var indexRecord = codec.getIndexRecord();\n        if (codec !== origin) {\n            return updateindexRecordOrigin(origin, indexRecord);\n        }\n        return indexRecord;\n    }\n    return monoidIndexRecord.empty;\n};\nvar isRecursiveCodecIndexable = true;\nvar isIndexableCodec = function (codec) {\n    return (((isInterfaceCodec(codec) || isStrictCodec(codec)) &&\n        Object.keys(codec.props).some(function (key) { return isLiteralCodec(codec.props[key]); })) ||\n        ((isExactCodec(codec) || isRefinementCodec(codec)) && isIndexableCodec(codec.type)) ||\n        (isIntersectionCodec(codec) && codec.types.some(isIndexableCodec)) ||\n        (isUnionCodec(codec) && codec.types.every(isIndexableCodec)) ||\n        (isRecursiveCodecIndexable && isRecursiveCodec(codec)));\n};\n/**\n * @internal\n */\nexport var getIndexRecord = function (codecs) {\n    var len = codecs.length;\n    if (len === 0 || !codecs.every(isIndexableCodec)) {\n        return monoidIndexRecord.empty;\n    }\n    var firstCodec = codecs[0];\n    var ir = cloneIndexRecord(getCodecIndexRecord(firstCodec, firstCodec, firstCodec));\n    for (var i = 1; i < len; i++) {\n        var codec = codecs[i];\n        var cir = getCodecIndexRecord(codec, codec, codec);\n        for (var k in ir) {\n            if (cir.hasOwnProperty(k)) {\n                var is = ir[k];\n                var cis = cir[k];\n                var _loop_1 = function (j) {\n                    var indexItem = cis[j];\n                    var index = is.findIndex(function (_a) {\n                        var v = _a[0];\n                        return v === indexItem[0];\n                    });\n                    if (index === -1) {\n                        is.push(indexItem);\n                    }\n                    else if (indexItem[2] !== is[index][2]) {\n                        delete ir[k];\n                        return \"break\";\n                    }\n                };\n                for (var j = 0; j < cis.length; j++) {\n                    var state_1 = _loop_1(j);\n                    if (state_1 === \"break\")\n                        break;\n                }\n            }\n            else {\n                delete ir[k];\n            }\n        }\n    }\n    return isIndexRecordEmpty(ir) ? monoidIndexRecord.empty : ir;\n};\nvar getTaggedUnion = function (index, tag, codecs, name) {\n    var len = codecs.length;\n    var indexWithPosition = index.map(function (_a) {\n        var v = _a[0], origin = _a[1];\n        return [\n            v,\n            codecs.findIndex(function (codec) { return codec === origin; })\n        ];\n    });\n    var findIndex = function (tagValue) {\n        for (var i = 0; i < indexWithPosition.length; i++) {\n            var _a = indexWithPosition[i], value = _a[0], position = _a[1];\n            if (value === tagValue) {\n                return position;\n            }\n        }\n    };\n    var isTagValue = function (u) { return findIndex(u) !== undefined; };\n    return new TaggedUnionType(name, function (u) {\n        if (!UnknownRecord.is(u)) {\n            return false;\n        }\n        var tagValue = u[tag];\n        var index = findIndex(tagValue);\n        return index !== undefined ? codecs[index].is(u) : false;\n    }, function (u, c) {\n        var dictionaryResult = UnknownRecord.validate(u, c);\n        if (dictionaryResult.isLeft()) {\n            return dictionaryResult;\n        }\n        var d = dictionaryResult.value;\n        var tagValue = d[tag];\n        if (!isTagValue(tagValue)) {\n            return failure(u, c);\n        }\n        var index = findIndex(tagValue);\n        var codec = codecs[index];\n        return codec.validate(d, appendContext(c, String(index), codec, d));\n    }, useIdentity(codecs, len) ? identity : function (a) { return codecs[findIndex(a[tag])].encode(a); }, codecs, tag);\n};\n/**\n * @since 1.3.0\n */\nvar TaggedUnionType = /** @class */ (function (_super) {\n    __extends(TaggedUnionType, _super);\n    function TaggedUnionType(name, is, validate, encode, codecs, tag) {\n        var _this = _super.call(this, name, is, validate, encode, codecs) /* istanbul ignore next */ // <= workaround for https://github.com/Microsoft/TypeScript/issues/13455\n         || this;\n        _this.tag = tag;\n        return _this;\n    }\n    return TaggedUnionType;\n}(UnionType));\nexport { TaggedUnionType };\n/**\n * @since 1.3.0\n */\nexport var taggedUnion = function (tag, codecs, name) {\n    if (name === void 0) { name = getUnionName(codecs); }\n    var indexRecord = getIndexRecord(codecs);\n    if (!indexRecord.hasOwnProperty(tag)) {\n        if (isRecursiveCodecIndexable && codecs.length > 0) {\n            console.warn(\"[io-ts] Cannot build a tagged union for \" + name + \", returning a de-optimized union\");\n        }\n        var U = union(codecs, name);\n        return new TaggedUnionType(name, U.is, U.validate, U.encode, codecs, tag);\n    }\n    return getTaggedUnion(indexRecord[tag], tag, codecs, name);\n};\n/**\n * @since 1.1.0\n */\nvar ExactType = /** @class */ (function (_super) {\n    __extends(ExactType, _super);\n    function ExactType(name, is, validate, encode, type) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.type = type;\n        _this._tag = 'ExactType';\n        return _this;\n    }\n    return ExactType;\n}(Type));\nexport { ExactType };\nvar getProps = function (codec) {\n    switch (codec._tag) {\n        case 'RefinementType':\n        case 'ReadonlyType':\n            return getProps(codec.type);\n        case 'InterfaceType':\n        case 'StrictType':\n        case 'PartialType':\n            return codec.props;\n        case 'IntersectionType':\n            return codec.types.reduce(function (props, type) { return Object.assign(props, getProps(type)); }, {});\n    }\n};\nvar stripKeys = function (o, props) {\n    var keys = Object.getOwnPropertyNames(o);\n    var shouldStrip = false;\n    var r = {};\n    for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        if (!hasOwnProperty.call(props, key)) {\n            shouldStrip = true;\n        }\n        else {\n            r[key] = o[key];\n        }\n    }\n    return shouldStrip ? r : o;\n};\nvar getExactTypeName = function (codec) {\n    if (isInterfaceCodec(codec)) {\n        return \"{| \" + getNameFromProps(codec.props) + \" |}\";\n    }\n    else if (isPartialCodec(codec)) {\n        return getPartialTypeName(\"{| \" + getNameFromProps(codec.props) + \" |}\");\n    }\n    return \"Exact<\" + codec.name + \">\";\n};\n/**\n * Strips additional properties\n * @since 1.1.0\n */\nexport var exact = function (codec, name) {\n    if (name === void 0) { name = getExactTypeName(codec); }\n    var props = getProps(codec);\n    return new ExactType(name, codec.is, function (u, c) {\n        var unknownRecordValidation = UnknownRecord.validate(u, c);\n        if (unknownRecordValidation.isLeft()) {\n            return unknownRecordValidation;\n        }\n        var validation = codec.validate(u, c);\n        if (validation.isLeft()) {\n            return validation;\n        }\n        return success(stripKeys(validation.value, props));\n    }, function (a) { return codec.encode(stripKeys(a, props)); }, codec);\n};\nexport { nullType as null };\nexport { undefinedType as undefined };\n/**\n * Use `UnknownArray` instead\n * @deprecated\n */\nexport { UnknownArray as Array };\n/**\n * Use `type` instead\n * @deprecated\n */\nexport { type as interface };\nexport { voidType as void };\n/**\n * @since 1.0.0\n * @deprecated\n */\nexport var getValidationError /* istanbul ignore next */ = function (value, context) { return ({\n    value: value,\n    context: context\n}); };\n/**\n * @since 1.0.0\n * @deprecated\n */\nexport var getDefaultContext /* istanbul ignore next */ = function (decoder) { return [\n    { key: '', type: decoder }\n]; };\n/**\n * @since 1.0.0\n * @deprecated\n */\nvar NeverType = /** @class */ (function (_super) {\n    __extends(NeverType, _super);\n    function NeverType() {\n        var _this = _super.call(this, 'never', function (_) { return false; }, function (u, c) { return failure(u, c); }, \n        /* istanbul ignore next */\n        function () {\n            throw new Error('cannot encode never');\n        }) || this;\n        _this._tag = 'NeverType';\n        return _this;\n    }\n    return NeverType;\n}(Type));\nexport { NeverType };\n/**\n * @since 1.0.0\n * @deprecated\n */\nexport var never = new NeverType();\n/**\n * @since 1.0.0\n * @deprecated\n */\nvar AnyType = /** @class */ (function (_super) {\n    __extends(AnyType, _super);\n    function AnyType() {\n        var _this = _super.call(this, 'any', function (_) { return true; }, success, identity) || this;\n        _this._tag = 'AnyType';\n        return _this;\n    }\n    return AnyType;\n}(Type));\nexport { AnyType };\n/**\n * Use `unknown` instead\n * @since 1.0.0\n * @deprecated\n */\nexport var any = new AnyType();\n/**\n * Use `UnknownRecord` instead\n * @since 1.0.0\n * @deprecated\n */\nexport var Dictionary = UnknownRecord;\n/**\n * @since 1.0.0\n * @deprecated\n */\nvar ObjectType = /** @class */ (function (_super) {\n    __extends(ObjectType, _super);\n    function ObjectType() {\n        var _this = _super.call(this, 'object', UnknownRecord.is, UnknownRecord.validate, identity) || this;\n        _this._tag = 'ObjectType';\n        return _this;\n    }\n    return ObjectType;\n}(Type));\nexport { ObjectType };\n/**\n * Use `UnknownRecord` instead\n * @since 1.0.0\n * @deprecated\n */\nexport var object = new ObjectType();\n/**\n * Use `brand` instead\n * @since 1.0.0\n * @deprecated\n */\nexport function refinement(codec, predicate, name) {\n    if (name === void 0) { name = \"(\" + codec.name + \" | \" + getFunctionName(predicate) + \")\"; }\n    return new RefinementType(name, function (u) { return codec.is(u) && predicate(u); }, function (i, c) {\n        var validation = codec.validate(i, c);\n        if (validation.isLeft()) {\n            return validation;\n        }\n        var a = validation.value;\n        return predicate(a) ? success(a) : failure(a, c);\n    }, codec.encode, codec, predicate);\n}\n/**\n * Use `Int` instead\n * @since 1.0.0\n * @deprecated\n */\nexport var Integer = refinement(number, Number.isInteger, 'Integer');\n/**\n * Use `record` instead\n * @since 1.0.0\n * @deprecated\n */\nexport var dictionary = record;\n/**\n * @since 1.0.0\n * @deprecated\n */\nvar StrictType = /** @class */ (function (_super) {\n    __extends(StrictType, _super);\n    function StrictType(name, is, validate, encode, props) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.props = props;\n        _this._tag = 'StrictType';\n        return _this;\n    }\n    return StrictType;\n}(Type));\nexport { StrictType };\n/**\n * Drops the codec \"kind\"\n * @since 1.1.0\n * @deprecated\n */\nexport function clean(codec) {\n    return codec;\n}\nexport function alias(codec) {\n    return function () { return codec; };\n}\n","import { SedData } from \"../types/sed_data\";\nimport { App, AppConf } from \"../core/app\";\nimport { BrowserMeasure } from \"./modules/browser-measure\";\nimport { CanvasRender } from \"./modules/canvas-render\";\nimport { ImageLocalStorage } from \"./modules/image-localstorage\";\nimport { M44 } from \"../types/m44\";\n\n// HACKY\nconst PROXY = 'https://cors-anywhere.herokuapp.com/';\n\ninterface Config {\n    renderLayers: string[];\n    board: AppConf[\"board\"];\n    dataUrl: string;\n    imageKey: string;\n}\n\nexport class M44Browser {\n\n    _app: App<HTMLImageElement, string> | null = null;\n    _conf: Config;\n\n    constructor(conf: Config) {\n        this._conf = conf;\n    }\n\n    async initialize(sedData: SedData) {\n        const imgls = new ImageLocalStorage({\n            dataUrl: this._conf.dataUrl,\n            imageKey: this._conf.imageKey\n        });\n        await imgls.sideLoad(\"countryside.png\", \"https://cors-anywhere.herokuapp.com/https://raw.githubusercontent.com/patricksurry/aide-memoire/master/images/bg_188_217/countryside.png\");\n        await imgls.sideLoad(\"outline.png\", \"https://cors-anywhere.herokuapp.com/https://raw.githubusercontent.com/patricksurry/aide-memoire/master/images/bg_188_217/outline.png\");\n        this._app = new App<HTMLImageElement, string>(\n            sedData,\n            new BrowserMeasure(),\n            new CanvasRender(),\n            imgls,\n            {\n                board: this._conf.board,\n                renderLayers: [\n                    \"background\",\n                    \"terrain\",\n                    \"rect_terrain\",\n                    \"obstacle\",\n                    \"unit\",\n                    \"badge\",\n                    \"tags\",\n                    \"label\"\n                ]\n            }\n        );\n    }\n\n    async drawScenario(scenario: M44): Promise<string> {\n        // TODO: Fix !\n        const base64 = await this._app!.drawScenario(scenario);\n        return base64;\n    }\n\n}\n","import { Measure } from \"../../core/types/measure\";\n\nexport class BrowserMeasure implements Measure {\n\n    _startTime: number | null = null;\n    _endTime: number | null = null;\n\n    start() {\n        this._startTime = performance.now();\n    }\n\n    end(): number {\n        if (this._startTime === null) {\n            throw new Error(\"startTime not intialized\");\n        }\n        this._endTime = performance.now();\n        return this._endTime - this._startTime;\n    }\n\n}\n","import { Renderer } from \"../../core/types/renderer\";\n\nexport class CanvasRender implements Renderer<HTMLImageElement, string> {\n\n    private _canvas: HTMLCanvasElement;\n    private _ctx: CanvasRenderingContext2D;\n    private _font: string | null ;\n\n    constructor() {\n        this._font = null;\n        this._canvas = document.createElement(\"canvas\");\n        this._ctx = this._canvas.getContext(\"2d\")!;\n\n        // DEBUG\n\n        const appEl = document.getElementById(\"app\") as HTMLDivElement;\n        appEl.appendChild(this._canvas);\n    }\n\n    async renderRect(x: number, y: number, w: number, h: number, style: string) {\n        this._ctx.fillStyle = style;\n        this._ctx.fillRect(x, y, w, h);\n    }\n\n    async renderDashedLine(x1: number, y1: number, x2: number, y2: number, opts: { width: number, step: number, length: number, style: string }) {\n        this._ctx.strokeStyle = opts.style;\n        this._ctx.lineWidth = opts.width;\n\n        this._ctx.beginPath();\n        this._ctx.setLineDash([ opts.length, opts.step ]);\n        this._ctx.moveTo(x1, y1);\n        this._ctx.lineTo(x2, y2);\n        this._ctx.stroke();\n    }\n\n    /**\n     * @return {string} Base64\n     */\n    async getResult(): Promise<string> {\n        return this._canvas.toDataURL(\"image/png\");\n    }\n\n    async loadFont(fontPath: string): Promise<void> {\n        this._font = fontPath;\n    }\n\n    async renderImage(img: HTMLImageElement, x: number, y: number): Promise<void> {\n        this._ctx.drawImage(img, x, y);\n    }\n\n    async renderText(text: string, x: number, y: number, w: number, h: number): Promise<void> {\n        if (!this._font) {\n            throw new Error(\"font_not_set\");\n        }\n        this._ctx.fillStyle = \"rgba(0, 0, 0, 0.7)\";\n        this._ctx.font = this._font;\n        this._ctx.textAlign = \"center\";\n        this._ctx.fillText(text, x, y, w);\n    }\n\n    async resize(width: number, height: number): Promise<void> {\n        this._canvas.width = width;\n        this._canvas.height = height;\n    }\n\n}\n","import { ImageStorage } from \"../../core/types/imagestorage\";\n\n// HACKY\nconst PROXY = 'https://cors-anywhere.herokuapp.com/';\n\n/**\n * Avoid CORS\n * @url {https://stackoverflow.com/questions/19183180/how-to-save-an-image-to-localstorage-and-display-it-on-the-next-page}\n */\nfunction convertToBase64(canvas: HTMLCanvasElement, img: HTMLImageElement) {\n    canvas.width = img.width;\n    canvas.height = img.height;\n\n    const ctx = canvas.getContext(\"2d\")!;\n    ctx.drawImage(img, 0, 0);\n\n    const dataUrl = canvas.toDataURL(\"image/png\");\n    return dataUrl;\n}\n\n/**\n * Avoid Canvas\n * @url {https://stackoverflow.com/questions/22172604/convert-image-url-to-base64}\n */\nfunction toDataUrl(url: string): Promise<string> {\n    const xhr = new XMLHttpRequest();\n    return new Promise((resolve, reject) => {\n        xhr.onload = function() {\n            const reader = new FileReader();\n            reader.onloadend = function() {\n                if (reader.result === null) {\n                    reject(\"Cannot convert an image\");\n                } else {\n                    resolve(reader.result.toString());\n                }\n            }\n            reader.readAsDataURL(xhr.response);\n        };\n        xhr.onerror = reject;\n        xhr.open('GET', PROXY + url);\n        xhr.responseType = 'blob';\n        xhr.send();\n    });\n}\n\n/**\n * Avoid CORS and Canvas\n * @url {https://stackoverflow.com/questions/29644474/how-to-be-able-to-convert-image-to-base64-and-avoid-same-origin-policy}\n */\nfunction toBase64UsingBytes(url: string): Promise<string> {\n    const xhr = new XMLHttpRequest();\n    return new Promise((resolve, reject) => {\n        xhr.open('GET', url, true);\n\n        xhr.responseType = 'arraybuffer';\n\n        xhr.onload = function(e) {\n           if (this.status == 200) {\n               const uInt8Array = new Uint8Array(this.response); // Note:not xhr.responseText\n\n               for (let i = 0, len = uInt8Array.length; i < len; ++i) {\n                   uInt8Array[i] = this.response[i];\n               }\n\n               const byte3 = uInt8Array[4]; // byte at offset 4\n               resolve(byte3.toString());\n           }\n        }\n        xhr.onerror = function(err) {\n            reject(err);\n        }\n\n        xhr.send();\n    });\n}\n\nfunction createImageFromBase64(base64: string): Promise<HTMLImageElement> {\n    const image = new Image();\n    return new Promise((resolve, reject) => {\n        image.onload = () => {\n            resolve(image);\n        }\n        image.onerror = (err) => {\n            reject(err);\n        }\n        image.src = base64;\n    });\n}\n\nfunction createImage(url: string): Promise<HTMLImageElement> {\n    const image = new Image();\n    return new Promise((resolve, reject) => {\n        image.crossOrigin = 'Anonymous'\n        image.onload = () => {\n            resolve(image);\n        }\n        image.onerror = (err) => {\n            reject(err);\n        }\n        image.src = PROXY + url;\n    });\n}\n\ninterface Config {\n    dataUrl: string;\n    imageKey: string;\n}\n\nexport class ImageLocalStorage implements ImageStorage<HTMLImageElement> {\n\n    private _conf: Config;\n    private _memory: { [imageName: string]: HTMLImageElement } = {};\n    /** imageName: base64 */\n    private _cache: { [imageName: string]: string } = {}\n    /** used to convert images to base64 */\n    private _canvas: HTMLCanvasElement;\n\n    constructor(conf: Config) {\n        this._conf = conf;\n        this._memory = {};\n        this._canvas = document.createElement(\"canvas\");\n\n        const storage = localStorage.getItem(conf.imageKey);\n        if (storage === undefined || storage === null) {\n            // initialize storage\n            console.log(`[IMGREPO] initializing storage \"${conf.imageKey}\"`);\n            localStorage.setItem(conf.imageKey, \"{}\");\n        } else {\n            console.log(`[IMGREPO] cache loaded from storage \"${conf.imageKey}\"`);\n            this._cache = JSON.parse(storage);\n        }\n    }\n\n    async sideLoad(imageName: string, url: string) {\n        const img = await createImage(url);\n        const base64 = convertToBase64(this._canvas, img);\n\n        this._memory[imageName] = img;\n        this._cache[imageName] = base64;\n        this._saveCache();\n\n    }\n\n    async get(imageName: string): Promise<HTMLImageElement> {\n        if (imageName in this._memory) {\n            return this._memory[imageName];\n        } else if (imageName in this._cache) {\n            console.log(`[IMGREPO] Loading from cache '${imageName}'`);\n            const base64 = this._cache[imageName];\n            const img = await createImageFromBase64(base64);\n\n            this._memory[imageName] = img;\n\n            return img;\n        } else {\n            console.log(`[IMGREPO] Fetching '${imageName}'`)\n            const img = await createImage(this._conf.dataUrl + imageName);\n            const base64 = await convertToBase64(this._canvas, img);\n\n            this._memory[imageName] = img;\n            this._cache[imageName] = base64;\n            this._saveCache();\n\n            return img;\n        }\n    }\n\n    _saveCache() {\n        const imageKey = this._conf.imageKey;\n        localStorage.setItem(imageKey, JSON.stringify(this._cache));\n    }\n\n}\n","import { ImageStorage } from \"./types/imagestorage\";\nimport { SedData } from \"../types/sed_data\";\nimport { M44 } from \"../types/m44\";\nimport { Board } from \"../types/board\";\nimport { IconRepo } from \"./utils/icon-repo\";\nimport { IconDict } from \"./utils/icon-dict\";\nimport { Measure } from \"./types/measure\";\nimport { Renderer } from \"./types/renderer\";\n\nexport interface AppConf {\n    renderLayers: string[]\n    board: {\n        hex_size: [number, number];\n        unitTL: [number, number];\n        tag_offset: [number, number];\n        badge_size: [number, number];\n        background_color: [number, number, number],\n        border_color: [number, number, number],\n        border_width: number,\n        margin: [number, number, number, number],\n        dash_color: [number, number, number],\n        dash_length: [number, number],\n        dash_width: number,\n        board_sizes: {\n            standartd: [number, number],\n            overlord: [number, number],\n            brkthru: [number, number]\n        },\n        layers: [\n            \"background\",\n            \"terrain\",\n            \"lines\",\n            \"rect_terrain\",\n            \"obstacle\",\n            \"unit\",\n            \"badge\",\n            \"tags\",\n            \"label\"\n        ]\n    }\n}\n\nexport class App<IMG, RES> {\n\n    _imageRepo: ImageStorage<IMG>;\n    _sedData: SedData | null;\n    _measure: Measure;\n    _renderer: Renderer<IMG, RES>;\n    _conf: AppConf;\n\n    constructor(\n        sedData: SedData,\n        measure: Measure,\n        renderer: Renderer<IMG, RES>,\n        imageRepo: ImageStorage<IMG>,\n        conf: AppConf\n    ) {\n        this._sedData = sedData;\n        this._measure = measure;\n        this._renderer = renderer;\n        this._imageRepo = imageRepo;\n        this._conf = conf;\n    }\n\n    async drawScenario(scenario: M44): Promise<RES> {\n        console.log(\"[APP] drawing scenario\");\n        const sedData = this._sedData;\n\n        if (sedData === null || scenario === null) {\n            console.error(\"[APP] Please intialize both sedData and scenario before drawScenario()\");\n            throw new Error(\"data_or_scenario_not_initialized\");\n        }\n\n        // Gather information\n\n        const board = new Board({\n            boardFace: sedData.editor.board_settings.board_face,\n            boardSize: sedData.editor.board_settings.board_size.list.standard\n        });\n\n        const size = this._conf.board.board_sizes.standartd;\n\n        console.log(\"[APP] creating dictionary of all icons with their names\");\n        const iconDict = new IconDict();\n\n        console.log(\"[APP] creating terrain dictionary\");\n        for (const category of sedData.editor.terrain.item) {\n            for (const terrain of category.list.item) {\n                iconDict.set(terrain.name, terrain.icon);\n            }\n        }\n\n        console.log(\"[APP] creating unit dictionary\");\n        for (const category of sedData.editor.unit.item) {\n            for (const unit of category.list.item) {\n                iconDict.set(unit.name, unit.icon);\n            }\n        }\n\n        console.log(\"[APP] creating obstacle dictionary\");\n        for (const category of sedData.editor.obstacle.item) {\n            for (const obstacle of category.list.item) {\n                iconDict.set(obstacle.name, obstacle.icon);\n            }\n        }\n\n        console.log(\"[APP] creating marker dictionary\");\n        for (const category of sedData.editor.marker.item) {\n            for (const marker of category.list.item) {\n                iconDict.set(marker.name, marker.icon);\n            }\n        }\n\n        console.log(\"[APP] creating badge dictionary\");\n        for (const badge of sedData.editor.badges.item) {\n            iconDict.set(badge.name, badge.icon);\n        }\n\n        // Prepare repo and renderer\n\n        const iconRepo = new IconRepo(this._imageRepo, iconDict);\n\n        const renderer = this._renderer;\n        await renderer.loadFont(\"32px Arial\");\n        await renderer.resize(size[0], size[1]);\n\n        async function fillBck(img: IMG) {\n            for (const hexagon of board.all()) {\n                await renderer.renderImage(\n                    img,\n                    parseFloat(hexagon.posX),\n                    parseFloat(hexagon.posY)\n                );\n            }\n        }\n\n        // Pre-fill background\n\n        if (this._conf.renderLayers.includes(\"background\")) {\n            this._measure.start();\n            switch(scenario.board.face) {\n                case \"BEACH\": {\n                    const img = await this._imageRepo.get(\"beach.png\");\n                    await fillBck(img);\n                    break;\n                }\n                case \"COUNTRY\": {\n                    const img = await this._imageRepo.get(\"countryside.png\");\n                    await fillBck(img);\n                    break;\n                }\n                case \"DESERT\": {\n                    const img = await this._imageRepo.get(\"sand.png\");\n                    await fillBck(img);\n                    break;\n                }\n                case \"WINTER\": {\n                    const img = await this._imageRepo.get(\"snow.png\");\n                    await fillBck(img);\n                    break;\n                }\n                default: {\n                    throw new Error(`Undefined board face \"${scenario.board.face}\"`);\n                }\n            }\n            const outlineImg = await this._imageRepo.get(\"outline.png\");\n            await fillBck(outlineImg);\n            console.log(`[APP] Background tiles rendered in ${this._measure.end()}ms`);\n        }\n\n        if (this._conf.renderLayers.includes(\"lines\")) {\n            const firstHex = board.get(0, 8);\n            const secondHex = board.get(0, 18);\n            const bottomHex = board.get(8, 8);\n\n            const l1x = parseFloat(firstHex.posX);\n            const l2x = parseFloat(secondHex.posX);\n\n            const y1 = parseFloat(firstHex.posY);\n            const y2 = parseFloat(bottomHex.posY) + this._conf.board.hex_size[1];\n\n            // const rightLine = board.get(0, 9);\n            await renderer.renderDashedLine(l1x, y1, l1x, y2, {\n                length: 12,\n                step: 8,\n                width: 4,\n                style: \"rgba(178, 34, 34, 0.8)\"\n            });\n            await renderer.renderDashedLine(l2x, y1, l2x, y2, {\n                length: 12,\n                step: 8,\n                width: 4,\n                style: \"rgba(178, 34, 34, 0.8)\"\n            });\n        }\n\n        // Render Layers\n\n        this._measure.start();\n        for (const hex of scenario.board.hexagons) {\n            const { row, col } = hex;\n            const { posX, posY } = board.get(row, col);\n            const x = parseFloat(posX); const y = parseFloat(posY);\n\n            if (hex.terrain && this._conf.renderLayers.includes(\"terrain\")) {\n                const img = await iconRepo.getRotated(hex.terrain.name, hex.terrain.orientation);\n                await renderer.renderImage(img, x, y);\n            }\n            if (hex.rect_terrain && this._conf.renderLayers.includes(\"rect_terrain\")) {\n                const img = await iconRepo.getRotated(hex.rect_terrain.name, hex.rect_terrain.orientation);\n                await renderer.renderImage(img, x, y);\n            }\n            if (hex.obstacle && this._conf.renderLayers.includes(\"obstacle\")) {\n                const img = await iconRepo.getRotated(hex.obstacle.name, hex.obstacle.orientation);\n                await renderer.renderImage(img, x, y);\n            }\n            if (hex.tags && this._conf.renderLayers.includes(\"tags\")) {\n                for (const tag of hex.tags) {\n                    const img = await iconRepo.get(tag.name);\n                    await renderer.renderImage(img, x, y);\n                }\n            }\n            if (hex.unit && this._conf.renderLayers.includes(\"unit\")) {\n                const img = await iconRepo.get(hex.unit.name);\n                await renderer.renderImage(img, x, y);\n            }\n            if (hex.unit && hex.unit.badge && this._conf.renderLayers.includes(\"badge\")) {\n                const img = await iconRepo.get(hex.unit.badge);\n                await renderer.renderImage(img, x, y);\n            }\n        }\n        if (this._conf.renderLayers.includes(\"label\")) {\n            for (const label of scenario.board.labels) {\n                const hex = board.get(label.row, label.col);\n                await renderer.renderText(\n                    label.text.join(\"\\n\"),\n                    parseInt(hex.posX),\n                    parseInt(hex.posY),\n                    188,\n                    217\n                );\n            }\n        }\n        console.log(`[APP] scenario rendered successfully in ${this._measure.end()}ms`);\n\n        // Finish\n\n        const resultImg = await renderer.getResult();\n        return resultImg;\n    }\n}\n","export class IconDict {\n\n    private _iconDict: { [name: string]: string } = {};\n\n    constructor() {\n        this._iconDict = {};\n    }\n\n    get(name: string) {\n        if (name in this._iconDict) {\n            return this._iconDict[name];\n        } else {\n            throw new Error(`Icon for name \"${name}\" doesn't exists`);\n        }\n    }\n\n    set(name: string, icon: string): boolean {\n        if (name in this._iconDict) {\n            console.log(`[IMGDICT] \"${name}\" already exists`);\n            return false;\n        }\n        this._iconDict[name] = icon;\n        return true;\n    }\n\n    exist(name: string) {\n        if (name in this._iconDict) {\n            return true;\n        }\n        return false;\n    }\n\n}\n","import { IconDict } from \"./icon-dict\";\nimport { ImageStorage } from \"../types/imagestorage\";\n\nfunction replaceAt(str: string, index: number, replacement: string) {\n    return str.substr(0, index) + replacement + str.substr(index + replacement.length);\n}\n\nexport class IconRepo<IMG> {\n\n    _imageRepo: ImageStorage<IMG>;\n    _iconDict: IconDict;\n    _memCache: { [name: string]: IMG };\n\n    constructor(imageRepo: ImageStorage<IMG>, iconDict: InstanceType<typeof IconDict>) {\n        this._imageRepo = imageRepo;\n        this._iconDict = iconDict;\n        this._memCache = { };\n    }\n\n    async get(name: string): Promise<IMG> {\n        if (name in this._memCache) {\n            return this._memCache[name];\n        } else {\n            const url = this._iconDict.get(name);\n            const img = await this._imageRepo.get(url);\n\n            this._memCache[name] = img;\n            return img;\n        }\n    }\n\n    async getRotated(name: string, orientation?: number): Promise<IMG> {\n        if (!orientation) {\n            return this.get(name);\n        }\n        const rotatedName = name + \"_\" + orientation;\n        if (rotatedName in this._memCache) {\n            return this._memCache[rotatedName];\n        } else {\n            if (!this._iconDict.exist(rotatedName)) {\n                const url = this._iconDict.get(name);\n                const rotatedIcon = replaceAt(\n                    url,\n                    url.length - 5, // river1.png -> riverX.png\n                    orientation.toString()\n                );\n                this._iconDict.set(rotatedName, rotatedIcon);\n            }\n            const url = this._iconDict.get(rotatedName);\n            const img = await this._imageRepo.get(url);\n\n            this._memCache[rotatedName] = img;\n            return img;\n        }\n    }\n\n}\n","import { SedData, BoardSize, Hexagon } from \"./sed_data\";\n\ntype BoardSettings = SedData[\"editor\"][\"board_settings\"];\n\nexport interface BoardConf {\n    boardSize: BoardSize;\n    boardFace: BoardSettings[\"board_face\"];\n}\n\n/**\n * Used to determine x, y position in board of hexagons\n */\nexport class Board {\n\n    _conf: BoardConf;\n    _board: {\n        [row: number]: {\n            [col: number]: Hexagon;\n        };\n    };\n\n    constructor(conf: BoardConf) {\n        this._conf = conf;\n        this._board = {};\n\n        conf.boardSize.hexagons.item.forEach((hexagon) => {\n            const { row, col } = hexagon;\n            const iRow = parseInt(row);\n            const iCol = parseInt(col);\n\n            if (this._board[iRow]) {\n                this._board[iRow][iCol] = hexagon;\n            } else {\n                this._board[iRow] = {\n                    [iCol]: hexagon\n                };\n            }\n        });\n    }\n\n    rows(): number {\n        return parseInt(this._conf.boardSize.nbrRows);\n    }\n\n    cols(): number {\n        return parseInt(this._conf.boardSize.nbrCols);\n    }\n\n    /** Get position of hexagon in board */\n    get(row: number, col: number): Hexagon {\n        if (row in this._board && col in this._board[row]) {\n            return this._board[row][col];\n        } else {\n            throw new Error(`hexagon [${row}, ${col}] doesn't exists on board`);\n        }\n    }\n\n    /** Check if hexagon exists in board */\n    exists(row: number, col: number): boolean {\n        if (row in this._board && col in this._board[row]) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Iterate over all hexagons in board\n     * @desc Used to fill board background with background tilesets\n     */\n    *all(): IterableIterator<Hexagon> {\n        for (const [row, cols] of Object.entries(this._board)) {\n            for (const [col, hex] of Object.entries(cols)) {\n                yield hex;\n            }\n        }\n\n    }\n\n}\n","import * as t from \"io-ts\";\nimport { EUnitName, EBoardFace } from \"./shared\";\n\nexport const BoardUnit = t.strict({\n    name: EUnitName,\n    badge: t.union([t.undefined, t.string]),\n    nbr_units: t.union([t.undefined, t.string])\n});\nexport type BoardUnit = t.TypeOf<typeof BoardUnit>;\n\nexport const BoardTerrain = t.strict({\n    name: t.string,\n    orientation: t.union([t.undefined, t.number])\n});\nexport type BoardTerrain = t.TypeOf<typeof BoardTerrain>;\n\nexport const BoardObstacle = t.strict({\n    name: t.string,\n    orientation: t.union([\n        t.undefined,\n        t.number\n    ])\n});\nexport type BoardObstacle = t.TypeOf<typeof BoardObstacle>;\n\nexport const BoardRectTerrain = t.strict({\n    name: t.string,\n    orientation: t.union([t.undefined, t.number])\n});\nexport type BoardRectTerrain = t.TypeOf<typeof BoardRectTerrain>;\n\nexport const BoardTag = t.strict({\n    name: t.string\n});\nexport type BoardTag = t.TypeOf<typeof BoardTag>;\n\nexport const BoardLabel = t.strict({\n    row: t.number,\n    col: t.number,\n    text: t.array(t.string)\n});\nexport type BoardLabel = t.TypeOf<typeof BoardLabel>;\n\nexport const Board = t.strict({\n    type: t.string,\n    face: EBoardFace,\n    hexagons: t.array(t.strict({\n        row: t.number,\n        col: t.number,\n        obstacle: t.union([\n            t.undefined,\n            BoardObstacle\n        ]),\n        unit: t.union([\n            t.undefined,\n            BoardUnit\n        ]),\n        rect_terrain: t.union([\n            t.undefined,\n            BoardRectTerrain,\n        ]),\n        terrain: t.union([\n            t.undefined,\n            BoardTerrain\n        ]),\n        tags: t.union([\n            t.undefined,\n            t.array(BoardTag)\n        ]),\n    })),\n    labels: t.array(BoardLabel)\n});\n\nexport type Board = t.TypeOf<typeof Board>;\n\nexport const M44 = t.strict({\n    meta_data: t.strict({\n        status: t.string,\n        software: t.string\n    }),\n    game_info: t.strict({\n        date_begin: t.string,\n        front: t.string,\n        type: t.string,\n        starting: t.string,\n        side_player1: t.string,\n        side_player2: t.string,\n        country_player1: t.string,\n        country_player2: t.string,\n        cards_player1: t.number,\n        cards_player2: t.number,\n        victory_player1: t.number,\n        victory_player2: t.number\n    }),\n    board: Board,\n    packs: t.strict({\n        base: t.union([t.undefined, t.number]),\n        terrain: t.union([t.undefined, t.number]),\n        eastern: t.union([t.undefined, t.number]),\n        pacific: t.union([t.undefined, t.number]),\n        air: t.union([t.undefined, t.number]),\n        mediterranean: t.union([t.undefined, t.number]),\n        battlemap: t.union([t.undefined, t.number]),\n        campaign: t.union([t.undefined, t.number]),\n        winterwars: t.union([t.undefined, t.number])\n    }),\n    text: t.strict({\n        en: t.strict({\n            name: t.string,\n            subtitle: t.string,\n            description: t.string,\n            rules: t.string,\n            historical: t.string,\n            victory: t.string,\n            bibliography: t.union([t.undefined, t.string])\n        })\n    })\n});\n\nexport type M44 = t.TypeOf<typeof M44>;\n","import * as t from \"io-ts\";\nimport {\n    Language,\n    PickerTab,\n    UnitSide,\n    MarkerType,\n    ObstacleType,\n    TerrainType,\n    EWeapon,\n    EPack,\n    EFlatFaceType,\n    EShape,\n    ELandscape,\n    EDeltaAngle,\n    EArmy,\n    EOffset,\n    Side\n} from \"./shared\";\n\nexport const Hexagon = t.strict({\n    col: t.string, // number\n    row: t.string, // number\n    posX: t.string, // number\n    posY: t.string, // number\n    _type: t.string\n});\nexport type Hexagon = t.TypeOf<typeof Hexagon>;\n\nexport const BoardSize = t.strict({\n    value: t.string, // type\n    nbrCols: t.string, // number\n    nbrRows: t.string, // number\n    width: t.string, // number\n    height: t.string, // number\n    access: t.string,\n    label: t.string,\n    hexagons: t.strict({\n        item: t.array(Hexagon),\n        _type: t.string\n    }),\n    _type: t.string\n});\nexport type BoardSize = t.TypeOf<typeof BoardSize>;\n\nexport const SedData = t.strict({\n    editor: t.strict({\n        language: t.string,\n        languages: t.strict({\n            item: t.array(Language),\n            _type: t.string\n        }),\n        picker_tabs: t.strict({\n            item: t.array(PickerTab),\n            _type: t.string\n        }),\n        label: t.strict({\n            accesskey: t.string,\n            hex_group: t.string,\n            help: t.string,\n            _type: t.string\n        }),\n        filter: t.strict({\n            accesskey: t.string,\n            elevation: t.strict({\n                any: t.string,\n                elevation: t.string,\n                _type: t.string\n            }),\n            landscape: t.strict({\n                any: t.string,\n                winter: t.string,\n                sand: t.string,\n                jungle: t.string,\n                country: t.string,\n                _type: t.string\n            }),\n            transport: t.strict({\n                any: t.string,\n                road: t.string,\n                rail: t.string,\n                airfield: t.string,\n                water: t.string,\n                _type: t.string\n            }),\n            type: t.strict({\n                any: t.string,\n                natural: t.string,\n                artificial: t.string,\n                _type: t.string\n            }),\n            _type: t.string\n        }),\n        validation: t.strict({\n            accesskey: t.string,\n            _type: t.string\n        }),\n        unit: t.strict({\n            item: t.array(UnitSide),\n            _type: t.string\n        }),\n        marker: t.strict({\n            item: t.array(MarkerType),\n            _type: t.string\n        }),\n        obstacle: t.strict({\n            item: t.array(ObstacleType),\n            _type: t.string\n        }),\n        terrain: t.strict({\n            item: t.array(TerrainType),\n            _type: t.string\n        }),\n        badges: t.strict({\n            item: t.array(t.strict({\n                weapon: t.strict({\n                    item: t.union([\n                        t.strict({\n                            _type: t.string,\n                            __text: EWeapon\n                        }),\n                        t.array(t.strict({\n                            _type: t.string,\n                            __text: EWeapon\n                        }))\n                    ]),\n                    _type: t.string\n                }),\n                name: t.string,\n                label: t.string,\n                icon: t.string,\n                packs: t.union([\n                    t.strict({\n                        item: t.union([\n                            t.strict({\n                                _type: t.string,\n                                __text: EPack\n                            }),\n                            t.array(t.strict({\n                                _type: t.string,\n                                __text: EPack\n                            }))\n                        ]),\n                        _type: t.string\n                    }),\n                    t.strict({\n                        _type: t.string\n                    })\n                ]),\n                _type: t.string\n            })),\n            _type: t.string\n        }),\n        flat_faces: t.dictionary(t.string, t.union([\n            t.strict({\n                name: t.string,\n                type: EFlatFaceType,\n                shape: EShape,\n                landscape: t.union([\n                    ELandscape,\n                    t.undefined\n                ]),\n                nbrOrientation: t.union([\n                    t.literal(\"3\"),\n                    t.literal(\"6\"),\n                    t.literal(\"2\"),\n                    t.undefined\n                ]), // number\n                manmade: t.union([t.string, t.undefined]), // boolean\n                elevation: t.union([t.string, t.undefined]), // boolean\n                vegetation: t.union([t.string, t.undefined]),\n                angle: t.union([\n                    t.literal(\"90\"),\n                    t.undefined\n                ]), // number\n                deltaAngle: t.union([\n                    EDeltaAngle,\n                    t.undefined\n                ]), // number\n                bridge: t.union([t.string, t.undefined]), // boolean\n                water: t.union([t.string, t.undefined]), // boolean\n                road: t.union([t.string, t.undefined]), // boolean\n                block: t.union([t.string, t.undefined]), // boolean\n                bunker: t.union([t.string, t.undefined]), // boolean\n                army: t.union([\n                    EArmy,\n                    t.undefined\n                ]), // nation\n                weapon: t.union([\n                    EWeapon,\n                    t.undefined\n                ]), // weapon\n                rail: t.union([t.string, t.undefined]), // boolean\n                transport: t.union([t.string, t.undefined]), // boolean\n                landmark: t.union([t.string, t.undefined]), // boolean\n                air: t.union([t.string, t.undefined]), // boolean\n                buildings: t.union([t.string, t.undefined]), // boolean\n                medal: t.union([t.string, t.undefined]), // boolean\n                offset: t.union([\n                    EOffset,\n                    t.undefined\n                ]), // offset position\n                packs: t.union([\n                    t.strict({\n                        item: t.union([\n                            t.array(EPack),\n                            EPack\n                        ]),\n                        _type: t.string\n                    }),\n                    t.strict({\n                        _type: t.string\n                    })\n                ]),\n                label: t.string,\n                icon: t.string,\n                _type: t.string\n            }),\n            t.string // _type\n        ])),\n        board_settings: t.strict({\n            board_face: t.strict({\n                list: t.strict({\n                    item: t.array(t.strict({\n                        value: t.string,\n                        label: t.string,\n                        _type: t.string\n                    })),\n                    _type: t.string\n                }),\n                _type: t.string\n            }),\n            board_size: t.strict({\n                list: t.strict({\n                    standard: BoardSize,\n                    overlord: BoardSize,\n                    brkthru: BoardSize,\n                    _type: t.string\n                }),\n                _type: t.string\n            }),\n            _type: t.string\n        }),\n        packs: t.strict({\n            list: t.strict({\n                item: t.array(t.strict({\n                    name: t.string,\n                    required: t.union([t.string, t.undefined]), // number\n                    privilege: t.string,\n                    label: t.string,\n                    pieces: t.union([\n                        t.strict({\n                            item: t.union([\n                                t.array(t.strict({\n                                    nbr: t.string, // number\n                                    face1: t.string,\n                                    face2: t.string,\n                                    _type: t.string\n                                })),\n                                t.strict({\n                                    nbr: t.string,\n                                    face1: t.string,\n                                    face2: t.string,\n                                    _type: t.string\n                                }),\n                                t.string\n                            ]),\n                            _type: t.string\n                        }),\n                        t.strict({\n                            _type: t.string\n                        })\n                    ]),\n                    _type: t.string\n                })),\n                _type: t.string,\n            }),\n            _type: t.string\n        }),\n        online: t.strict({\n            status: t.strict({\n                label: t.string,\n                list: t.strict({\n                    item: t.array(t.strict({\n                        name: t.string,\n                        access: t.string,\n                        label: t.string,\n                        _type: t.string\n                    })),\n                    _type: t.string,\n                }),\n                _type: t.string,\n            }),\n            scenario_id: t.string,\n            original_scenario_id: t.string,\n            expert_mode: t.string,\n            _type: t.string\n        }),\n        battle: t.strict({\n            front: t.strict({\n                label: t.string,\n                list: t.strict({\n                    item: t.array(t.strict({\n                        name: t.string,\n                        label: t.string,\n                        _type: t.string\n                    })),\n                    _type: t.string,\n                }),\n                _type: t.string\n            }),\n            operation: t.strict({\n                label: t.string,\n                suggest: t.string,\n                _type: t.string\n            }),\n            start_date: t.string,\n            end_date: t.string,\n            same_date: t.string,\n            type: t.strict({\n                label: t.string,\n                list: t.strict({\n                    item: t.array(t.strict({\n                        name: t.string,\n                        label: t.string,\n                        _type: t.string\n                    })),\n                    _type: t.string\n                }),\n                _type: t.string,\n            }),\n            _type: t.string\n        }),\n        game: t.strict({\n            starting: t.strict({\n                label: t.string,\n                list: t.strict({\n                    item: t.array(t.strict({\n                        name: t.string,\n                        label: t.string,\n                        _type: t.string\n                    })),\n                    _type: t.string,\n                }),\n                _type: t.string,\n            }),\n            side: t.strict({\n                label: t.string,\n                axis: Side,\n                allies: Side,\n                _type: t.string,\n            }),\n            command: t.string,\n            victory: t.string,\n            player: t.strict({\n                top: t.string,\n                bottom: t.string,\n                _type: t.string\n            }),\n            _type: t.string\n        }),\n        text_panel: t.dictionary(t.string, t.union([\n            t.strict({\n                name: t.string,\n                subtitle: t.string,\n                historical: t.string,\n                description: t.string,\n                rules: t.string,\n                victory: t.string,\n                bibliography: t.string,\n                _type: t.string\n            }),\n            t.string\n        ])),\n        _type: t.string\n    })\n});\n\nexport type SedData = t.TypeOf<typeof SedData>;\n","import * as t from \"io-ts\";\n\nexport const EArmy = t.union([\n    t.literal(\"us\"),\n    t.literal(\"ger\"),\n    t.literal(\"ru\"),\n    t.literal(\"jp\"),\n    t.literal(\"uk\")\n]);\n\nexport const ELocale = t.union([\n    t.literal(\"en\"),\n    t.literal(\"fr\"),\n    t.literal(\"de\"),\n    t.literal(\"nl\"),\n    t.literal(\"da\"),\n    t.literal(\"fi\"),\n    t.literal(\"it\"),\n    t.literal(\"pl\"),\n    t.literal(\"pt\"),\n    t.literal(\"es\"),\n    t.literal(\"sv\"),\n    t.literal(\"no\"),\n    t.literal(\"el\"),\n    t.literal(\"c\") // other\n]);\n\nexport const Language = t.strict({\n    locale: ELocale,\n    label: t.string,\n    _type: t.string\n});\n\nexport const PickerTab = t.strict({\n    name: t.string,\n    label: t.string,\n    accesskey: t.string,\n    _type: t.string\n});\n\nexport const Unit = t.strict({\n    name: t.string,\n    label: t.string,\n    icon: t.string,\n    _type: t.string\n});\n\nexport const UnitSide = t.strict({\n    name: EArmy,\n    label: t.string,\n    list: t.strict({\n        item: t.array(Unit),\n        _type: t.string\n    }),\n    _type: t.string\n});\n\nexport const Marker = t.strict({\n    name: t.string,\n    label: t.string,\n    icon: t.string,\n    _type: t.string\n});\n\nexport const MarkerType = t.strict({\n    name: t.string,\n    label: t.string,\n    list: t.strict({\n        item: t.array(Marker),\n        _type: t.string\n    }),\n    _type: t.string,\n});\n\nexport const Obstacle = t.strict({\n    name: t.string,\n    label: t.string,\n    icon: t.string,\n    _type: t.string\n});\n\nexport const ObstacleType = t.strict({\n    name: t.string,\n    label: t.string,\n    list: t.strict({\n        item: t.array(Obstacle),\n        _type: t.string\n    }),\n    _type: t.string,\n});\n\nexport const Terrain = t.strict({\n    name: t.string,\n    label: t.string,\n    icon: t.string,\n    _type: t.string\n});\n\nexport const TerrainType = t.strict({\n    name: t.string,\n    label: t.string,\n    list: t.strict({\n        item: t.array(Terrain),\n        _type: t.string\n    }),\n    _type: t.string\n});\n\nexport const Side = t.strict({\n    label: t.string,\n    list: t.strict({\n        item: t.array(t.strict({\n            name: t.string,\n            label: t.string,\n            _type: t.string\n        })),\n        _type: t.string\n    }),\n    _type: t.string\n});\n\nexport const EFlatFaceType = t.union([\n    t.literal(\"terrain\"),\n    t.literal(\"rect_terrain\"),\n    t.literal(\"obstacle\"),\n    t.literal(\"unit\"),\n    t.literal(\"tag\"),\n]);\n\nexport const EShape = t.union([\n    t.literal(\"hex\"),\n    t.literal(\"rect\"),\n    t.literal(\"wire\"),\n    t.literal(\"sand\"),\n    t.literal(\"hog\"),\n    t.literal(\"hog\"),\n    t.literal(\"unit\"),\n    t.literal(\"circle\")\n]);\n\nexport const ELandscape = t.union([\n    t.literal(\"country\"),\n    t.literal(\"sand\"),\n    t.literal(\"jungle\"),\n    t.literal(\"winter\"),\n]);\n\nexport const EDeltaAngle = t.union([\n    t.literal(\"180\"),\n    t.literal(\"60\"),\n    t.literal(\"-30\"),\n    t.literal(\"-60\"),\n]);\n\nexport const EWeapon = t.union([\n    t.literal(\"infantry\"),\n    t.literal(\"special_forces\"),\n    t.literal(\"armor\"),\n    t.literal(\"elite_armor\"),\n    t.literal(\"artillery\"),\n    t.literal(\"plane\"),\n    t.literal(\"vehicle\")\n]);\n\nexport const EOffset = t.union([\n    t.literal(\"TR\"),\n    t.literal(\"BL\"),\n    t.literal(\"C\"),\n])\n\nexport const EBoardFace = t.union([\n    t.literal(\"WINTER\"),\n    t.literal(\"BEACH\"),\n    t.literal(\"COUNTRY\"),\n    t.literal(\"DESERT\")\n]);\n\nexport const EPack = t.union([\n    t.literal(\"winterwars\"),\n    t.literal(\"base\"),\n    t.literal(\"pacific\"),\n    t.literal(\"terrain\"),\n    t.literal(\"air\"),\n    t.literal(\"eastern\"),\n    t.literal(\"mediterranean\"),\n    t.literal(\"campaign\"),\n    t.literal(\"battlemap\"),\n]);\n\nexport const EUnitName = t.union([\n    t.literal(\"infus\"),\n    t.literal(\"inf2us\"),\n    t.literal(\"tankus\"),\n    t.literal(\"tank2us\"),\n    t.literal(\"gunus\"),\n    t.literal(\"plnus\"),\n    t.literal(\"vehus\"),\n    t.literal(\"infger\"),\n    t.literal(\"inf2ger\"),\n    t.literal(\"tankger\"),\n    t.literal(\"tank2ger\"),\n    t.literal(\"gunger\"),\n    t.literal(\"plnger\"),\n    t.literal(\"vehger\"),\n    t.literal(\"infru\"),\n    t.literal(\"inf2ru\"),\n    t.literal(\"tankru\"),\n    t.literal(\"tank2ru\"),\n    t.literal(\"gunru\"),\n    t.literal(\"plnru\"),\n    t.literal(\"vehru\"),\n    t.literal(\"infjp\"),\n    t.literal(\"inf2jp\"),\n    t.literal(\"tankjp\"),\n    t.literal(\"tank2jp\"),\n    t.literal(\"gunjp\"),\n    t.literal(\"plnjp\"),\n    t.literal(\"vehjp\"),\n    t.literal(\"infbrit\"),\n    t.literal(\"inf2brit\"),\n    t.literal(\"tankbrit\"),\n    t.literal(\"tank2brit\"),\n    t.literal(\"gunbrit\"),\n    t.literal(\"plnbrit\"),\n    t.literal(\"vehbrit\"),\n]);\n","import { AppConf } from \"../core/app\";\n\nexport const config = {\n    imageRepo: {\n        dataUrl: \"http://static.daysofwonder.com/memoir44/sed_images/\",\n        imageDir: \"m44-images\"\n    },\n    board: {\n        hex_size: [188, 217],\n        unitTL: [44, 80],\n        tag_offset: [39, -42],\n        badge_size: [64, 64],\n        background_color: [255, 255, 255],\n        border_color: [0, 0, 0],\n        border_width: 1,\n        margin: [10, 10, 10, 10],\n        dash_color: [214, 35, 44],\n        dash_length: [36, 9],\n        dash_width: 7,\n        board_sizes: {\n            standartd: [2570, 1737],\n            overlord: [5014, 1737],\n            brkthru: [2570, 3039]\n        },\n        layers: [\n            \"background\",\n            \"terrain\",\n            \"lines\",\n            \"rect_terrain\",\n            \"obstacle\",\n            \"unit\",\n            \"badge\",\n            \"tags\",\n            \"label\"\n        ]\n    } as AppConf[\"board\"]\n};\n","import * as t from \"io-ts\";\nimport * as reporters from \"io-ts-reporters\";\nimport { M44Browser } from \"../browser/index\";\nimport { config } from \"./config\";\nimport { M44 } from \"../types/m44\";\nimport { SedData } from \"../types/sed_data\";\n\n(async () => {\n    // Initialize HTML Elements\n    const canvasEl = document.getElementById(\"m44-canvas\") as HTMLInputElement | null;\n    const sedDataInp = document.getElementById(\"m44-sed-data\") as HTMLInputElement | null;\n    const m44Inp = document.getElementById(\"m44-scenario\") as HTMLInputElement | null;\n\n    if (canvasEl === null) {\n        throw new Error(\"m44-canvas <canvas/> is missing!\");\n    }\n    if (sedDataInp === null) {\n        throw new Error(\"m44-sed-data <input/> is missing!\");\n    }\n    if (m44Inp === null) {\n        throw new Error(\"m44-scenario <input/> is missing!\");\n    }\n\n    const m44 = new M44Browser({\n        board: config.board,\n        dataUrl: config.imageRepo.dataUrl,\n        imageKey: config.imageRepo.imageDir,\n        renderLayers: [\n            \"background\",\n            \"terrain\",\n            \"lines\",\n            \"rect_terrain\",\n            \"obstacle\",\n            \"unit\",\n            \"badge\",\n            \"tags\",\n            \"label\"\n        ]\n    });\n\n    // Initialize localStorage\n    const lsSedData = localStorage.getItem(\"m44-sed-data\") as SedData | null;\n    const lsScenario = localStorage.getItem(\"m44-scenario\") as M44 | null;\n\n    if (lsSedData) {\n        console.log(\"[UI] SedData stored in localStorage, retrieving...\");\n        await m44.initialize(JSON.parse(lsSedData));\n    }\n    if (lsScenario) {\n        console.log(\"[UI] M44 Scenario store in localStorage, retrieving...\");\n        const str = await m44.drawScenario(JSON.parse(lsScenario));\n        console.log(str);\n    }\n\n\n    sedDataInp.addEventListener(\"change\", (e) => {\n        console.log(\"[UI] Loading sedData from <input/>\");\n        const reader = new FileReader();\n        const target = e.target as HTMLInputElement;\n        const file = target.files![0];\n        reader.onload = (e) => {\n            const rTarget = e.target as any;\n            const data = rTarget.result!;\n\n            try {\n                const sData = JSON.parse(data);\n                console.log(sData);\n                const result = SedData.decode(sData);\n                const report = reporters.reporter(result);\n                if (report.length) {\n                    console.error(`[UI] ${report}`);\n                } else {\n                    localStorage.setItem(\"m44-sed-data\", JSON.stringify(sData));\n                }\n            } catch(err) {\n                console.error(err);\n                console.error(`[UI] Cannot parse '${file.name}' loaded from <input/>`);\n            }\n            console.log(`[UI] SedData '${file.name}' loaded from <input/>`);\n        }\n        reader.readAsText(file);\n    });\n\n    m44Inp.addEventListener(\"change\", (e) => {\n        console.log(\"[UI] Loading scenario from <input/>\");\n        const reader = new FileReader();\n        const target = e.target as HTMLInputElement;\n        const file = target.files![0];\n        reader.onload = (e) => {\n            const rTarget = e.target as any;\n            const data = rTarget.result!;\n\n            try {\n                const scen = JSON.parse(data);\n                const result = M44.decode(scen);\n                const report = reporters.reporter(result);\n                if (report.length) {\n                    console.error(`[UI] ${report}`);\n                } else {\n                    localStorage.setItem(\"m44-scenario\", JSON.stringify(scen));\n                }\n            } catch(err) {\n                console.log(err);\n                console.error(`[UI] Cannot parse '${file.name}' loaded from <input/>`);\n            }\n            console.log(`[UI] Scenario '${file.name}' loaded from <input/>`);\n        }\n        reader.readAsText(file);\n    });\n})();\n"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/2CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1oBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3qBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC30CA;AACA;AACA;AACA;AAGA;AACA;AASA;AAKA;AAHA;AAIA;AACA;AAEA;;;;;;AACA;AACA;AACA;AACA;AACA;;AAAA;AACA;;AAAA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAEA;AAEA;;;;;AAEA;;AAAA;AACA;;;;AACA;AAEA;AAAA;AA3CA;;;;;;;;;;;;;;;ACfA;AAAA;AAEA;AACA;AAcA;AAZA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAjBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AAMA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;;;AACA;AACA;;;;AACA;AAEA;;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;AACA;AAEA;;AAEA;AACA;;;AACA;;;AACA;AAEA;;;AACA;;;;AACA;AAEA;;;AACA;;;;AACA;AAEA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AACA;AAEA;;;AACA;AACA;;;;AACA;AAEA;AAAA;AA/DA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AASA;AANA;AACA;AACA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;;;;;AACA;;AAAA;AACA;AAEA;AACA;AACA;;;;;AAEA;AAEA;;;;;;AACA;AACA;;AACA;AACA;AACA;AACA;;AAAA;AAEA;AAEA;;AAEA;AACA;;AAAA;AACA;;AAAA;AAEA;AACA;AACA;AAEA;;;;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAhEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzGA;AACA;AACA;AAqCA;AAQA;AAOA;AACA;AACA;AACA;AACA;AACA;AAEA;;AA8DA;;;;;;;AACA;;;;AAAA;AACA;;AAAA;;;;;;;;;;;;;;;;;;;;AAMA;;;;;AArEA;AACA;AAEA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;;AACA;AAAA;;AACA;AAAA;AACA;AACA;;;;;;;;;AACA;;;;;;;;;AAEA;;AACA;AAAA;;AACA;AAAA;AACA;AACA;;;;;;;;;AACA;;;;;;;;;AAEA;;AACA;AAAA;;AACA;AAAA;AACA;AACA;;;;;;;;;AACA;;;;;;;;;AAEA;;AACA;AAAA;;AACA;AAAA;AACA;AACA;;;;;;;;;AACA;;;;;;;;;AAEA;;AACA;AAAA;AACA;AACA;;;;;;;;;AAIA;AAEA;AACA;;AAAA;AACA;;AAAA;AAcA;AACA;AACA;;AACA;AAKA;AAKA;AAKA;;;AAdA;;AAAA;AACA;;AAAA;AACA;AAGA;;AAAA;AACA;;AAAA;AACA;AAGA;;AAAA;AACA;;AAAA;AACA;AAGA;;AAAA;AACA;;AAAA;AACA;;AAEA;AACA;AACA;;AAEA;;AAAA;AACA;;AAAA;AACA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AANA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;;AALA;;;AAQA;AAEA;;;;AACA;;;;AAAA;AACA;AACA;AACA;AAAA;AAEA;AACA;;AAAA;AACA;;AAAA;;;AAEA;AACA;;AAAA;AACA;;AAAA;;;AAEA;AACA;;AAAA;AACA;;AAAA;;;AAEA;;;;AACA;;;;AAAA;AACA;;AAAA;AACA;;AAAA;;;;;;;;;;;;;;;;;AAGA;AACA;;AAAA;AACA;;AAAA;;;AAEA;AACA;;AAAA;AACA;;AAAA;;;;;;;;;;;;;;;;;AAGA;;;;AACA;;;;AAAA;AACA;AACA;;AAAA;;;;;;;;;;;;;;;;;AASA;AAIA;;AAAA;AACA;;;;AACA;AACA;AAAA;AAhNA;;;;;;;;;;;;;;;AC1CA;AAIA;AAFA;AAGA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAhCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACGA;AACA;AACA;AAEA;AAMA;AACA;AACA;AACA;AACA;AAEA;;;;;;AACA;AACA;;AAEA;AACA;;AAAA;AAEA;AACA;;;;AAEA;AAEA;;;;;;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;;AAAA;AAEA;AACA;;;;AAEA;AAEA;AAAA;AAjDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACEA;;AAEA;AACA;AASA;AAAA;AACA;AACA;AAEA;;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;;;;;;AACA;;;;AAAA;;;;AACA;;;;AAAA;AACA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA;AAEA;AAAA;AAlEA;;;;;;;;;;;;;;;;;;;;;;ACZA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAGA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACrHA;AACA;AAkBA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACvXA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC/NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpCA;;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;;AAAA;;;AAEA;AACA;AACA;;AAAA;AACA;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AACA;;;;;A","sourceRoot":""}